{"pages":[{"title":"About","text":"“过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。” ——陈素封 人生最后悔的事情就是，我本可以。 我踏着别人的脚印，一步一步走到这里，骨子里的自卑一直支配着我所有的行动。 ”我要有能做我自己的自由，与敢做我自己的胆量“林语堂先生的一句话毫不客气的直击我的心灵。 不愿妥协，却无比懦弱。心比天高，却仍旧堕落。 够了，我要站起来，走自己的路了。","link":"/about/index.html"},{"title":"Home","text":"","link":"/home/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hdu3836 [Tarjan强连通分量]+[缩点]","text":"题目链接:http://acm.hdu.edu.cn/showproblem.php?pid=3836 tarjan强连通分量缩点入门题. 最近想搞一搞图论吧..但是又菜的一批,网络流又搞不动,就只能玩玩最短路,强连通分量的水题这样子.就这么一道水题数组开小了不RE,TLE是怎么回事…害得我debug半小时心态爆炸. >> 题意证明两集合等价需要证明A是B子集和B是A子集,且性质可以传递,现在有n个子集,m个已知证明,求最少还需多少次证明得到所有集合均等价. 题解tarjan求强连通分量缩点,填边使余下的强连通点构成一个强连通图即可. 具体来说就是将每个集合看为一个圆点共n个,tarjan缩为cnt个方点.求所有方点中入度为0点记a个,出度为0点b个.需要添加的边就是max(a,b)个. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Problem : 3836 ( Equivalent Sets ) Judge Status : Accepted// RunId : 29352864 Language : G++ Author : nicknameuser// Code Render Status : Rendered By HDOJ G++ Code Render Version 0.01 Beta#include &lt;bits/stdc++.h&gt;using namespace std;#define mem(a,b) memset(a,b,sizeof(a))const int MAXN = 20000 + 10;struct Edge{ int to,next;}edge[MAXN * 3];int Stack[MAXN],head[MAXN],dfn[MAXN],low[MAXN],Belong[MAXN];bool InStack[MAXN],in[MAXN],out[MAXN];int tim,tot,cnt,top;int n,m;void init() //初始化{ mem(Stack,0); mem(head,-1); mem(dfn,0); mem(low,0); mem(Belong,0); mem(in,0); mem(out,0); tim = tot = cnt = top = 0;}void tarjan(int u) //缩点入Belong{ int v; dfn[u] = low[u] = ++tim; Stack[top++] = u; InStack[u] = 1; for(int i = head[u];i != -1 ;i = edge[i].next){ v = edge[i].to; if(!dfn[v]){ tarjan(v); low[u] = min(low[u],low[v]); } else if(InStack[v]) low[u] = min(low[u],dfn[v]); } if(dfn[u] == low[u]){ cnt++; do{ v = Stack[--top]; InStack[v] = 0; Belong[v] = cnt; }while(u != v); }}void addedge(int u,int v) //加边函数{ edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;}int main(){ while(cin&gt;&gt;n&gt;&gt;m){ init(); while(m--){ int u,v; scanf(\"%d%d\",&amp;u,&amp;v); addedge(u,v); } for(int i = 1 ;i &lt;= n;++i){ if(!dfn[i]) tarjan(i); } for (int i = 1; i &lt;= n; ++i){ //入度出度为零点的个数 for (int j = head[i]; j != -1; j = edge[j].next){ int v=edge[j].to; if (Belong[v] != Belong[i]){ out[Belong[i]] = 1; in[Belong[v]] = 1; } } } if(cnt == 1){ //图为强连通图时,无需加边 puts(\"0\"); continue; } int a,b; a = b = 0; for(int i = 1;i &lt;= cnt;++i){ if(!in[i]) a++; if(!out[i]) b++; } printf(\"%d\\n\",max(a,b)); } return 0;} 最近没心情写博客了…毕竟学期末实在太恐怖了,大雾,高数,高听,三门课正在教我做人,抽点时间做两道题,等全都考完把板子总结挂上吧…","link":"/post/HDU_3836/"},{"title":"HDU_1043 Eight [搜索] + [康托展开]","text":"题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=1043 kuangbin搜索进阶第一题卡了我一天..?? 菜哭了😫 英文单词solve拼错wa几发也是够了… >> 题意：经典八数码问题，如题： 问移动x是否可以将八数码归位，即变为顺序为 1 2 3 4 5 6 7 8 x 如果可以输出移动路径（ruld表示）否则输出unsolvable 题解逆向bfs预处理打表，哈希，康托展开。 由结果开始bfs寻找所有情况（9! = 362880）记录路径结果，打表输出. 优化： 简单的打表会发生MLE，所以可以将9个数字变成9位数字存储（即令x为0，1,2,3,4,5,6,7,8,x就是123456789）由于情况并不多，直接判重会产生极大浪费，所以使用哈希表存储判重，但是如何设计哈希表是个问题,可以使用康托展开来设计哈希表。 康托展开原文链接 https://blog.csdn.net/wbin233/article/details/72998375 康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。设有n个数（1，2，3，4,…,n），可以有组成不同(n!种)的排列组合，康托展开表示的就是是当前排列组合在n个不同元素的全排列中的名次。$$X=a[n](n-1)!+a[n-1](n-2)!+…+a[i](i-1)!+…+a[1]0!$$其中, a[i]为整数，并且0 &lt;= a[i] &lt;= i, 0 &lt;= i &lt; n, 表示当前未出现的的元素中排第几个，这就是康托展开。 康托展开 1234567891011121314static const int FAC[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}; // 阶乘int cantor(int *a, int n){ int x = 0; for (int i = 0; i &lt; n; ++i) { int smaller = 0; // 在当前位之后小于其的个数 for (int j = i + 1; j &lt; n; ++j) { if (a[j] &lt; a[i]) smaller++; } x += FAC[n - i - 1] * smaller; // 康托展开累加 } return x; // 康托展开值} 逆康托展开 12345678910111213141516171819static const int FAC[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}; // 阶乘//康托展开逆运算void decantor(int x, int n){ vector&lt;int&gt; v; // 存放当前可选数 vector&lt;int&gt; a; // 所求排列组合 for(int i=1;i&lt;=n;i++) v.push_back(i); for(int i=m;i&gt;=1;i--) { int r = x % FAC[i-1]; int t = x / FAC[i-1]; x = r; sort(v.begin(),v.end());// 从小到大排序 a.push_back(v[t]); // 剩余数里第t+1个数为当前位 v.erase(v.begin()+t); // 移除选做当前位的数 }} 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 4e5 + 10;struct node{ int p; //当前状态，存为数字 int hash; //哈希表索引值 string r; //当前路径 int pos; //x所在位置};string ans[MAXN]; //路径表bool vis[MAXN]; const int func[10] ={1,1,2,6,24,120,720,5040,40320,362880}; //阶乘表const int dir[4][2] = {-1,0,1,0,0,-1,0,1}; //上下左右方向const string dirc = \"durl\"; //方向字符int Hash(int p) //哈希表（康托展开方法）{ int a[9]; for(int i = 8;i &gt;= 0;--i){ a[i] = p % 10; p /= 10; } int ret = 0; for(int i = 0;i &lt; 9;++i){ int small = 0; for(int j = i + 1;j &lt; 9;++j){ if(a[j] &lt; a[i]) small++; } ret += (func[8-i] * small); } return ret;}void Swap(int &amp;p,int pos1,int pos2) //x移动时交换位置{ int a[9]; for(int i = 8;i &gt;= 0;--i){ a[i] = p % 10; p/=10; } swap(a[pos1],a[pos2]); for(int i = 0;i &lt; 9;++i){ p = p * 10 + a[i]; }}void bfs() //bfs打表{ queue&lt;node&gt; que; node st; st.r = \"\"; st.pos = 8; st.p = 123456780; st.hash = Hash(st.p); vis[st.hash] = 1; ans[st.hash] = \"\"; que.push(st); while(!que.empty()){ node hd = que.front(); que.pop(); for(int i = 0;i &lt; 4;++i){ int x = hd.pos / 3 + dir[i][0]; int y = hd.pos % 3 + dir[i][1]; if(y &gt;= 0 &amp;&amp; y &lt; 3 &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; 3){ int pos = x * 3 + y; int p = hd.p; Swap(p,hd.pos,pos); if(!vis[Hash(p)]){ node t; t.p = p; t.pos = pos; t.r = hd.r + dirc[i]; t.hash = Hash(p); vis[t.hash] = 1; ans[t.hash] = t.r; que.push(t); } } } }}int main(){ bfs(); char s[9]; while(~scanf(\" %c\",&amp;s[0])){ for(int i = 1;i &lt; 9;++i){ scanf(\" %c\",&amp;s[i]); } int p = 0; for(int i = 0;i &lt; 9;++i){ //转化为数字 if(s[i] == 'x') p = p * 10 + 0; else p = p * 10 + (s[i] - '0'); } if(vis[Hash(p)]){ string s = ans[Hash(p)]; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl; } else{ cout&lt;&lt; \"unsolvable\"&lt;&lt;endl; } } return 0;}","link":"/post/HDU_1043/"},{"title":"C++ 学习笔记(二)","text":"decltype 类型制定符用处: 当我们不知道某个变量的类型而需要从表达式推断要定义的类型时,可以使用C++11的第二种类型说明符.,它的实际作用就是返回操作数的数据类型.在此过程中,编译器分析表达式并得到其类型,但实际运算表达式的值 >> 123const int ci = 0,&amp;cj = ci;decltype(ci) x = 0; //x 的数据类型是 const intdecltype(cj) y = x; //y 的数据类型是 const int&amp; 必须对其进行初始化,否则编译器会报错 decltype与引用 当decltype得到的数据类型是一个引用值,那么它只能作为赋值语句的左值出现,即必须初始化. 特性: 与auto相比,当decltype的表达式加双重括号代表其引用值. 12int i = 42;decltyp((i)) j = i; //j的类型是 int&amp; 必须对其初始化","link":"/post/cpp2/"},{"title":"C++ 学习笔记(一)","text":"[TOC] 变量的声明与定义声明关键字 extern 123extern int a; //声明int a; //声明并定义extern int a = 1; //定义 变量可以被多次声明,仅可定义一次 若想在多个文件中同时应用const 对象,需要在const前加extern >> 1extren const int a = 100; const 限定符对const 的引用(简称常量引用)例: 1234int i = 42; const int &amp;r1 = i; const int &amp;r2 = 42; const int &amp;r3 = r1 * 2; 常量引用可以对非常量执行,但是无法修改引用值,也不能通过引用值修改常量. 指向常量的指针const 可以令指针指向常量或非常量. 不过指针不能修改所指对象的值. 123456789 const double pi = 3.14; const double *cptr = &amp;pi; printf(\"%.2lf\\n\",*cptr); double dval = 3.16; cptr = &amp;dval; printf(\"%.2lf\\n\",*cptr);output:3.143.16 所谓指向常量的指针,仅仅是指不能通过该指针改变常量的值,但是可以通过其他方式改变 const指针即指针是对象,把指针本身定位常量 即指针本身指向不可更改,但可通过其改变其指向的非常量的值 1234int a = 0;int *const pa = &amp;a; //常量指针const double pi = 3.14;const double *const ppi = &amp;pi //指向常量的常量指针 顶层const 顶层const表示指针本身是个常量, 而底层const表示指针所指对象是个常量. 12345目前所见有int *const p = &amp;i; //顶层constconst double pi = 3.14; //顶层constconst double *ppi = &amp;pi;//底层constconst int &amp;r = i; //用于声明引用的const均为底层const 分别const是底层或顶层时,按定义区分即可. 在底层const对象的拷贝中,拷入与拷出必须拥有相同的底层const资格,或两者两者类型可以进行转换. 常量表达式即值不会改变,且值在编译过程中就可得到 123456例如 const int mx = 100;const int mxx = mx + 10;而如下表达式就不是const int x = get_size(); //编译过程无法得到其值,须运行时确定int y = 10; //值不确定 constexpr限定符将变量声明为constexpr类型,可由编译器来验证变量的值是否是个常量表达式. 且可用于声明函数,但此类函数须足够简单,能让编译器编译后即可得到结果.这样的函数,就可以去初始化constexpr变量 123constexpr int mf = 20;constexpr int limit = mf + 1;constexpr int sz = size(); //size() 为constexpr函数 constexpr 定义的指针和引用初始值受到严格限制. 即定义在任何函数中的变量均不可被constexpr修饰,因为函数体内的变量定义一般并不会存放在固定地址. 注意: 若constexpr定义中存在指针,则此指针为常量指针,即与其指向的对象无关. 12const int *p = &amp;i; //指向常量的指针constexpr int *q = &amp;j; //常量指针","link":"/post/cpp1/"},{"title":"C++格式化输出方法","text":"cout 浮点数格式化输出iomainip.h是I/O流控制的头文件 >> setiosflags操作符setiosflags() 算子实际上是一个库函数，它以一些标志作为参数，以达到特定作用。 标 志 作 用 ios::left 输出数据在本域宽范围内向左对齐 ios::right 输出数据在本域宽范围内向右对齐 ios::internal 数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充 ios::dec 设置整数的基数为 10 ios::oct 设置整数的基数为 8 ios::hex 设置整数的基数为 16 ios::showbase 强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头） ios::showpoint 强制输出浮点数的小点和尾数 0 ios::uppercase 在以科学记数法格式 E 和以十六进制输出字母时以大写表示 ios::showpos 对正数显示“+”号 ios::scientific 浮点数以科学记数法格式输出 ios::fixed 浮点数以定点格式（小数形式）输出 ios::unitbuf 每次输出之后刷新所有的流 ios::stdio 每次输出之后清除 stdout, stderr 1234//例如 double db = 123.456; cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;db&lt;&lt;endl;//设置为以浮点数格式输出，再设定保留2位小数（四舍五入）//多个标志符之间可以使用‘|’相连","link":"/post/cpp6/"},{"title":"C++ 学习笔记(三)","text":"考试周终于过去了😭然后现在懒散的一点不愿意学习可咋整.. 刷题的状态还有待恢复，先学学C++吧 >> 范围for语句12for (declaration : expression) statement expresstion是一个对象，表示一个序列 declaration负责定义一个变量，用于访问序列中的基本元素 cctype头文件函数123456789isalnum(c) // c是字母或者数组时为真isalpha(c) //c是字母iscntrl(c) //c是控制字符isxdigit(c) //c是16进制数字isdigit(c) //c是数字isspace(c) //c是空白（空格，制表符，回车符，换行符，进纸符(\\f,\\x0c,\\cL )）isgraph(c) //c不是空格但可以打印isupper(c)islower(c) 数组使用数组下标时，通常使用size_t类型，即与机器相关足够大的无符号整形，存在中 指针也是迭代器 1234567例如：int a[10]; //定义数组 int *s = &amp;a[0]; //定义头指针int *t = &amp;a[10]; //定义尾后指针//由于此用法极易出错，c++11增加标准库函数 begin(),end()int *beg = begin(a);int *last = end(a); string 的初始化string允许使用空字符结束的字符数组来初始化string对象 1string s(\"hello world\"); string 专门提供了一个名为c_str的成员函数，即返回c风格的字符串，即以空字符结束的字符数组的指针 1const char *str = s.c_str(); //将string转化为字符数组的指针类型 vector的数组初始化方法123int int_arr[] = {1,2,3,4,5,6};vector&lt;int&gt; ivec(begin(int_arr),end(int_arr)); //使用数组首指针与尾后指针初始化vector&lt;int&gt; subVec(int_arr+1,int_arr+4);","link":"/post/cpp3/"},{"title":"一维树状数组详解","text":"树状数组的简洁易用简直是比赛神器..而且理解也不难 我这样的菜鸡都学会了 那么就写一篇教程权当总结吧..以免日后忘了.. >> 要了解树状数组,首先需要了解它是用来做什么的.那么: 树状数组的问题模型 单点维护,区间查询(PUIQ问题) 区间维护,单点查询(IUPQ问题) 求逆序对问题 树状数组的逻辑模型如图:突然一看可能难以理解,那么是什么把它们联系起来的呢?接下来介绍lowbit函数 lowbit(求二进制数最后一位1的位置)这里用到了补码的原理: 即负数的补码为其二进制绝对值取反+1,而当其与其绝对值取&amp;操作时得到的恰好就是其二进制最后一位1的位置 例如:00001000(8)的负数补码为11111000(-8) 与操作后为00001000 而lowbit(8)的值就为 00001000; 则 lowbit函数代码 1234inline int lowbit(int x){ return x &amp; -x;} 这里就稍微偏个题顺便介绍一下inline(内联函数) C++关键字，在函数声明或定义中函数返回类型前加上关键字inline，即可以把函数指定为内联函数。 在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。此关键字仅是对编译器的一种建议,并非强制.对于内容较短且无循环的代码,inline的使用可以增加函数运行的效率,但其效率的增加是以代码长度为代价,所以,仅在短且无循环的函数前可以使用,其他情况避免使用. 原理 那么lowbit函数的用处是什么呢. 让我们以二进制思维稍微注意一下可以发现,每个序号的二进制数的后导0的个数,恰为其包含的数组的深度(自底向上的),设其为d,那么其包含的范围就是包括它向前的2^d个数.如100(4)为从100向前4个原数组中的数的和,而110(6)是从110向前2个原数组中的数的和. 我们令原数组为a[],树状数组为tree[]. 这时,我们可以理解tree数组中存储的到底是什么数据,那么对于以上问题模型,我们该如何求解呢. 更新(update函数)我们要更新原数组中某一个数,那么就得更新树状数组中所有包含它的数据,那么,都有哪组数据包含它呢,也就是寻找这个子节点的所有根节点的特点. 这时,就又轮到我们的lowbit函数上场了,x的所有父节点只需+ lowbit(x)```就可以得到.12345678那么update函数的代码(时间复杂度O(logn)):```cpp//x为需要修改的节点,v为a[x]增加的值,n是树状数组的最大范围.void update(int x,int v){ for(;x &lt;= n;x += lowbit(x)) tree[x] += v;} 查询(query函数)对于树状数组tree,我们可以了解其存储的值实质上是某一区间的前缀和.我们查询某一段区间(x,y)的值,就只需要求出y的前缀和减去x-1的前缀和这样得到的,就是区间(x,y)的和. 那么(1,x)区间的前缀和怎么求呢,仍然是lowbit函数,只需要做一遍更新的逆过程,即计算tree数组(x-&gt;1)的和就可以求出所有不重合的区间前缀和. 为什么tree(x-&gt;1)就是该区间的前缀和? 在二进制的视角下,x的数位上每一个1,都代表其一段域内的值,那么,每个1都必然与其他1的范围不重合例如:12345678910如此,query的代码就很明了了.```cppint query(int x){ int res = 0; for(;x &gt; 0;x -= lowbit(x)) res += tree[x]; return res;} 板子题链接(luoguP3374) 到此为止,我们讲解的就是PUIQ模型,即点更新,段查询. 怎么样代码是不是短到怀疑人生,这在赛场上写起来不是舒舒服服? 那么,接下来的IUPQ模型,就需要一个切入点来完成操作了. IUPQ模型的解题切入点—差分当我们想要进行段更新时,那么如果仍然用上面的代码,就不得不添加一个for循环,此时update函数的时间复杂度会上升到O(nlogn),那么,有没有什么方法来优化操作呢?解决方案就是–差分 差分,也就是定义一个差分数组b来存储a数组的差值,而tree作为数组b的树状数组. 即: 1234567b[1] = a[1]b[2] = a[2] - a[1]b[4] = a[4] - a[1]tree[1] = b[1]tree[2] = b[2] + tree[1]tree[4] = tree[2] + tree[3] + b[4] 那么这时的a数组值该如何得到呢? 对于b数组,+...+b[n]```12345而query函数刚好就是用来求b[n]的前缀和,也就是a[n]的值.那么更新操作呢,对于差分数组b,若我们想要更新```[l,r]```范围内的值+v,那么我们只需要将```b[l]```更新为```b[l] + v```就代表着```a[l] - a[n]```所有数都+1,而在```b[r+1]```处将+v的效果消除,即```b[r+1] - v 那么如何将这个操作更新在tree数组中,就是上文update的事情了. 即只需更新b[l]+v,b[r+1]-v即可 12update(l,v);update(r+1,-v); 复杂度同样为O(logn) 板子题链接(luoguP3368) 求逆序对问题问题模型,给定n个整数,求出逆序整数对数(即> a[v] && u < v```的整数对)12345678看见题目我们就可以写出O(n2)的暴力for来求解,但是如何将其用树状数组来优化到O(nlogn)呢这里用到桶排序的思想.首先让问题简单化一点,让n个整数a[i]均小于等于100.那么我们就可以开tree[105]的数组,每次读入更新一个数时,只需```update(a[i],1) 此时,比a[i]大的数字就是需要更新的逆序对对数,即- query(a[i])```因为当前共读入了i个数,那么求值亦可简化为```i - query[a[i]]```12345678910111213141516171819202122也就是读入一轮+每次查询就可得到总共的逆序对对数.时间复杂度O(nlogn)那么当数据足够大时,我们的数组存不下的时候呢,这时候,就轮到我们的核心思想,离散化出场了.对于离散化,个人理解就是由于想要利用桶数组,故将数据相对缩小(保证相对大小不变)到可以开到的数组那么大而减小空间需求.那么到底该如何实现,请看如下代码:```cpp离散化核心代码:struct node{ int v;//数值本身 int order;//原序列的的下标}a[500005];int dis[500005]; //用来存储原数第i个数的order下标是什么sort(a,a+n,cmp); //注意需要由大到小排for(int i = 1;i &lt;= n;++i) dis[a[i].order] = i; 原理很简单就只是按a[i].v的大小重排,并重新赋予他们相对大小不变,整体缩小的新的a[i].v 具体代码如下:(HDU2689) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define mem(n) memset(n,0,sizeof(n))using namespace std;int n;struct node{ int val,order; bool operator &lt; (const node &amp; x) const{ return this-&gt;val &lt; x.val; } }a[1005];int dis[1005]; //差分数组int tree[1005];inline int lowbit(int x){ return x &amp; -x;}void update(int x,int v){ for(;x &lt;= n;x +=lowbit(x)) tree[x] += v;}int query(int x){ int res = 0; for(;x &gt; 0;x -= lowbit(x)) res += tree[x]; return res;}int main(){ while(~scanf(\"%d\",&amp;n)){ mem(a); mem(dis); mem(tree); for(int i = 1;i &lt;=n;++i){ scanf(\"%d\",&amp;a[i].val); a[i].order = i; } sort(a + 1, a + 1 + n); for(int i = 1;i &lt;= n;++i){ dis[a[i].order] = i; } int cnt = 0; for(int i = 1;i &lt;= n;++i){ update(dis[i],1); cnt += i - query(dis[i]); } printf(\"%d\\n\",cnt); } return 0;}","link":"/post/一维树状数组详解/"},{"title":"各类排序代码及复杂度","text":"下午就要考数据结构了呀有点慌….所以看看排序抱抱佛脚..于是…写了堆排序就停不下来了呢… 所以就把上课老师讲的排序都写了一遍..交题都过了可是复杂度可能会有些小问题.. >> 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//-------------------------堆排序------------------------////时间复杂度 平均 O(nlogn) 最坏 O(nlogn)//空间复杂度 O(1)#include &lt;bits/stdc++.h&gt;using namespace std;int a[1000006],n;void PercDown(int a[],int i,int n) //O(logn){ if(2 * i + 1 &gt;= n) return ; else if(2 * i + 2 &gt;= n){ if(a[i * 2 + 1] &gt; a[i]) swap(a[i* 2 + 1] , a[i]); } else{ int p = i * 2 + 1,q = i * 2 + 2; if(a[p] &gt; a[q]) swap(p,q); if(a[i] &lt; a[q]){ swap(a[q],a[i]); PercDown(a,q,n); } }}//(i + 1) * 2 (+ 1) - 1 = 2 * i + 1 || 2 * i + 2;void HeapSort(int a[],int n){ for(int i = n/2;i &gt;= 0;--i){ //建堆（大根堆） PercDown(a,i,n); } for(int i = n-1;i &gt;= 0;--i){ //更新大根堆 swap(a[0],a[i]); PercDown(a,0,i); }}//-------------------------快速排序------------------------////时间复杂度 平均 O(nlogn) 最坏 O(n^{2})//空间复杂度 O(logn)#include &lt;bits/stdc++.h&gt;using namespace std;int a[1000006];void QuickSort(int a[],int l,int r) { int i,j,p; p = a[l]; i = l,j = r; while(i &lt; j){ while(i &lt; j &amp;&amp; a[j] &gt;= p){ //先移动右指针寻找大于哨兵的值 j--; } if(i != j){ a[i] = a[j]; } else break; while(i &lt; j &amp;&amp; a[i] &lt;= p){ //后移动左指针寻找小于哨兵的值 i++; } if(i != j){ a[j] = a[i]; } else break; } a[j] = p; //指针相碰，指针位置就是哨兵的最终位置 if(l &lt; j) QuickSort(a,l,j); if(j+1 &lt; r)QuickSort(a,j+1,r);}//-----------------------直接插入排序----------------------////时间复杂度 平均 O(n^{2}) 最坏 O(n^{2})//空间复杂度 O(1)#include &lt;bits/stdc++.h&gt;using namespace std;int a[1000006];void InsertSort(int a[],int n){ for(int i = 1;i &lt; n;++i){ int p = a[i]; for(int j = i;j &gt;= 0;--j){ if(a[j-1] &gt; p) a[j] = a[j-1]; else{ a[j] = p; break; } } }}//-------------------------希尔排序------------------------////时间复杂度 平均 O(nlogn) 最坏 O(n^{2})//空间复杂度 O(1)#include &lt;bits/stdc++.h&gt;using namespace std;int a[1000006];void ShellSort(int a[],int n){ for(int d = n/2;d &gt; 0;d/=2){ //以n/2为增量序列 for(int p = d;p &lt; n;++p){ int tmp = a[p]; int i = p; for(i = p;i &gt;= d &amp;&amp; a[i-d] &gt; tmp; i-=d) a[i] = a[i-d]; a[i] = tmp; } }}","link":"/post/sort/"},{"title":"大数运算模拟","text":"从前的大数模拟都是自己用字符串来敲的,突然看到同学的代码后释放了很多思维,不仅敲得快还不容易错,于是找个晚上敲下大数的一些模拟,留下板子记录一下. >> 对于负数加减模拟运算我们可以分情况讨论并编写另一个函数,即: 若两数均正 1* 若两数均负 ```ans = &apos;-&apos; + add(a,b) 若一正一负 1234567891011121314151617181920212223**可拟函数**```cppstring add_op(string a,string b){ string ans; if(a[0] == &apos;-&apos; &amp;&amp; b[0] == &apos;-&apos;){ a.erase(a.begin()); b.erase(b.begin()); ans = &apos;-&apos; + big_add(a,b); } else if(a[0] == &apos;-&apos;){ a.erase(a.begin()); ans = big_sub(b,a); } else if(b[0] == &apos;-&apos;){ b.erase(b.begin()); ans = big_sub(a,b); } else{ ans = big_add(a,b); } return ans;} 大数加法 123456789101112131415161718192021222324252627282930313233343536373839404142434445//不支持负数const int MAXN = 1e8 + 10;int t[MAXN];string big_add(string a,string b){ int len1 = a.size(); int len2 = b.size(); reverse(a.begin(),a.end()); //调换顺序方便处理 reverse(b.begin(),b.end()); if(len1 &lt; len2){ swap(a,b); //令a是数位较长的数 swap(len1,len2); } for(int i = 0;i &lt; len2;++i){ //t数组存在第i位上两数相加的结果,暂时不进位 t[i] = a[i] -'0' + b[i] - '0'; } for(int i = len2;i &lt; len1;++i){ t[i] = a[i] - '0'; } int flag = 0; //flag 标志是否需要进位 for(int i = 0;i &lt; len1;++i){ if(flag) { t[i]++; flag = 0; } if(t[i] &gt;= 10){ t[i]-=10; flag = 1; } } if(flag) t[len1] = 1; //处理最高位是否需要进位,若不需要令最高位为 0 else t[len1] = 0; string ans; flag = 0; for(int i = len1;i &gt;= 0 ;--i){ //去除前导0 if( flag == 0 &amp;&amp; t[i] == 0) continue; flag = 1; ans.push_back(t[i] + '0'); } if(ans.empty()) ans.push_back('0'); return ans;} 大数减法 12345678910111213141516171819202122232425262728293031323334353637383940const int MAXN = 1e8 + 10;int t[MAXN];string big_sub(string a,string b){ string ans; int len1 = a.size(); int len2 = b.size(); reverse(a.begin(),a.end()); //调换顺序便于处理 reverse(b.begin(),b.end()); for(int i = 0;i &lt; len2 ;++i){ //t数组保存第i位上两数之差 t[i] = a[i] - b[i]; } for(int i = len2;i &lt; len1;++i){ t[i] = a[i] - '0'; //若a位数较长,则长度超过b的位结果为a[i] - 0 } int flag = 0; for(int i = 0;i &lt; len1;++i){ //借位 if(flag){ flag = 0; t[i]--; } if(t[i] &lt; 0){ t[i]+=10; flag = 1; } } flag = 0; for(int i = len1-1;i &gt;= 0;--i){ //去除前导0 if(!flag &amp;&amp; t[i] == 0) continue; flag = 1; ans.push_back(t[i] + '0'); } if(ans.empty()) ans.push_back('0'); //若结果为0,答案 ans = 0 return ans;} 大数乘法 123456789101112131415161718192021222324252627282930313233int t[10000000];string mul(string a,string b){ reverse(a.begin(),a.end()); //交换顺序，方便计算 reverse(b.begin(),b.end()); int len1=a.size(); int len2=b.size(); for(int i = 0;i &lt; len1;++i) for(int j = 0;j &lt; len2;++j) t[i+j]=(a[i]-'0')*(b[j]-'0')+t[i+j]; //先整体乘起来，不进位 t[len1 + len2 -1] = 0; //进位 for(int i = 0;i &lt; len1 + len2;++i){ t[i+1] += t[i] / 10; t[i] %= 10; } int x = len1 + len2; //结果最长的位数 if(t[len1 + len2-1] == 0) x--; string ans = \"\"; int flag = 1; //flag用来做做去除前导零的标记 for(int i = x-1;i &gt;= 0;--i){ if(t[i] == 0 &amp;&amp; flag) { continue; } flag = 0; ans.push_back(t[i] + '0'); } if(ans.empty()) ans.push_back('0'); //若结果为零,返回\"0\" return ans;} 大数求模 12345678910//大数求模就很简单了,根据同余定理来按位求模就好了long long big_mod(string a,long long mod){ int len=a.size(); long long ans=0; for(int i=0;i&lt;len;++i) ans=(ans*10%mod+a[i]-&apos;0&apos;)%mod; return ans;}","link":"/post/大数/"},{"title":"矩阵快速幂","text":"矩阵快速幂啊…真是个好东西,fjut校赛题看到后心态爆炸..这板子题要是写不出不就被人拉下一题了…于是当机立断..现学2333..还好鼓捣很久之后把板子套上了…于是回来恶补矩阵快速幂,这记录一下. >> 连矩阵都没接触过的菜鸡表示..我要先学习一下矩阵是个啥..: 矩阵的加法和数乘都很简单百度便知,乘法才是我们矩阵快速幂需要了解的,这里介绍一下前置知识矩阵乘法. 矩阵乘法 两个矩阵可以相乘的矩阵需满足的条件左矩阵的列数必须要与右矩阵的行数相同简记,乘法过程就是左矩阵的行中每一个数字乘以右矩阵列中的每一个数,乘法过程如下 代码实现如下(结构体中的运算符重载): 123456789//方形矩阵.MAT operator*(MAT p) { MAT res; for(int i=0;i&lt;M;i++) for(int j=0;j&lt;M;j++) for(int k=0;k&lt;M;k++) res.a[i][j]=(res.a[i][j]+a[i][k]*p.a[k][j])%mod; return res; } 第二个前置知识.广义快速幂.所谓广义快速幂,就是指快速幂的思想(二进制思想),将中心运算修改.即 12345678910MAT qpow(MAT a,ll b){ MAT res = //初始化; while(b){ if(b &amp; 1) res = res * a ; //* 某种运算 a = a * a; b &gt;&gt;= 1; } return res;} 若是需要乘法运算,就将其* 改为+即可,若是矩阵乘运算,就将*改为矩阵乘的函数,或重载 *. 矩阵快速幂 介绍了这么多后,矩阵快速幂就差不多结束了….emm..毕竟两个一套就行了… 那么下面来说说矩阵快速幂的应用. 矩阵快速幂最棒的应用就在于它可以加速递推,例如斐波拉契数列,或随便的递推式.在O(logn)的时间复杂度下完成递推.","link":"/post/矩阵快速幂/"},{"title":"新的一天,新的Blog!","text":"哈哈哈经过一整天折腾我的blog终于要上线啦(实名认证过后)😁 虽然这么久了也没写过两篇博客,但是我还是有决心要坚持下来的,毕竟得有个总结学习的地方对吧(严肃). 更主要是…学过的东西全都忘得差不多了😭,才想起写点博客 毕竟我这么懒 emm~博客主要写一些题解和对算法的一些理解吧,顺便用来记一下c++,py的学习笔记好了. 想来这浑浑噩噩的一年也没沉淀下来啥,就有点灰心. 😔往事不堪回首,ICPC路还远的很,亦步亦趋往前走吧.","link":"/post/新的一天-新的blog!/"},{"title":"C++ 学习笔记(四)","text":"这次看的东西有点多..哦不..是看的有点随便..翻一翻就过去了… 感觉有点基础..?(怕不是自己太菜) 所以随便记一下好了.. >> 命名的强制类型转换123//强制类型转换的形式cast-name&lt;type&gt;(expression); //type 为目标类型，expression是要转换的值//cast-name则为{static_cast,dynamic_cast,const_cast,reinterpret_cast}中的一种 下面记录一下各个cast-name的意义 static_cast 任何具有明确意义的类型转换，只要不包含底层const，都可以使用static_cast 可以将大的算术类型转换为小的算术类型，而不产生warning 可以用其将存在void指针中的值转化出来，即： 123double d = 10;void *p = &amp;d;double *dp = static_cast&lt;double*&gt; p; //要注意的是避免转换后所得类型与指针类型不符，否则产生未定义后果 const_cast 对于常量对象转换为非常量对象的行为，即去掉const性质 const_cast仅能去掉const性质，不能转换类型 renterpret_cast 为运算对象的位模式提供较低层次的重新解释 emm…读不懂 大概意思就是..随便转换…? 就算转换完不能用也可以转换…所以转换时一定要明确其根本类型，就是它内部存的到底是什么类型，所以说使用它是非常危险的…现在的菜鸡水平还是先把它放在一边吧.. c++运算符优先级顺序表网上搬个优先级表😁 优先级 运算符 描述 结合性 1 :: 作用域解析 从左到右 2 a++ a-- 后缀自增与自减 *type*() *type*{} 函数风格转型 a() 函数调用 a[] 下标 . -&gt; 成员访问 3 ++a --a 前缀自增与自减 从右到左 +a -a 一元加与减 ! ~ 逻辑非和逐位非 (*type*) C 风格转型 *a 间接（解引用） &amp;a 取址 sizeof 取大小[注 1] co_await await 表达式 (C++20) new new[] 动态内存分配 delete delete[] 动态内存分配 4 .* -&gt;* 成员指针 从左到右 5 a*b a/b a%b 乘法、除法与余数 6 a+b a-b 加法与减法 7 &lt;&lt; &gt;&gt; 逐位左移与右移 8 &lt;=&gt; 三路比较运算符(C++20 起) 9 &lt; &lt;= 分别为 &lt; 与 ≤ 的关系运算符 &gt; &gt;= 分别为 &gt; 与 ≥ 的关系运算符 10 == != 分别为 = 与 ≠ 的关系运算符 11 a&amp;b 逐位与 12 ^ 逐位异或（互斥或） 13 ` ` 逐位或（可兼或） 14 &amp;&amp; 逻辑与 15 ` ` 16 a?b:c 三元条件[注 2] 从右到左 throw throw 运算符 co_yield yield 表达式 (C++20) = 直接赋值（C++ 类默认提供） += -= 以和及差复合赋值 *= /= %= 以积、商及余数复合赋值 &lt;&lt;= &gt;&gt;= 以逐位左移及右移复合赋值 &amp;= ^= ` =` 以逐位与、异或及或复合赋值 17 , 逗号 从左到右 局部对象 在c++中，名字有其作用域，对象有生命周期 局部静态对象（static）局部静态对象即在程序第一次调用函数时对其初始化，并直到程序结束才被销毁，且函数结束对其不产生影响 12345size_t const_calls(){ static size_t cnt = 0; return ++cnt;} 如上就是一个统计函数被调用多少次的函数，用到static 静态变量 const形参与实参当用实参初始化形参时，会忽略掉顶层const 函数参数定义时应尽量使用常量引用，即： func(const int &n)``` 1234567891011使用普通引用是一种较为常见的错误：令使用者认为可以改变其实参的值，而且大大限制了参数范围（无法传入常量）**（当然若函数体需要改变其实参的值，则必须使用普通引用）**#### 数组形参可以利用引用显式的传递一个固定大小的数组形参```cppvoid func(int (&amp;arr)[10]); //传递一个大小为10的int数组 由于c++中没有真正的多维数组，所以声明二维数组时，可以声明为指向数组的指针 12void func(int (*arr)[10]); //传递一个指向大小为10的数组的指针void func(int arr[][10]); //等价定义 main()函数的传参有些情况下我们需要给main传参而main的参数为 1main(int argc, char **argv); 传参方法：可以通过运行可执行文件时在命令行后添加字符串实现（传入参数为argv，而argc为argv中字符串的个数） 12$ g++ a.cpp -o a$ ./a a b c d initializer_list类型当函数实参数量未知，但类型相同，可使用initializer来传参，但传参需要加上{} initializer_list与其他容器不同的是，它内部元素永远是常量值，不能被改变。 1234567//标准库提供的操作initializer_list&lt;T&gt; lst;initializer_list&lt;T&gt; lst{a,b,c...};lst2(lst);lst.size();lst.begin();lst.end(); //即可以使用范围for循环 函数返回数组指针方法返回数组指针的函数形式如下： 12Type (*func(para_list)) [dimension]; //dimension为数组大小int (*func(int i))[10]; //返回指向大小为10的int类型数组指针 也可以使用尾置返回类型 1auto func(int i) -&gt; int(*)[10]; 或者使用decltype(): 12int arr[10];decltype(arr) *func(int i);","link":"/post/cpp4/"},{"title":"数论学习小结","text":"最近做题做到了两道数论…于是就翻了翻以前学过的知识点..发现…我忘光了… 所以这次写篇博客尝试着捡一捡.. 希望不要再忘了… >> gcd &amp; exgcdgcd又名共产党算法是求解最大公因数的算法，算法原理是初高中就学习过的辗转相除法。 所以..直接放代码： 12int gcd(int a,int b){return b == 0 ? a : gcd(b,a%b);} 辗转相除法的时间复杂度为O(logn) exgcd是求形如$ax+by=gcd(a,b) $类型多解问题的方法，使用它可以得到x,y的最小解 下面展开证明： 首先根据辗转相除法我们知道$$gcd(a,b) = gcd(b,a\\bmod b)$$所以$$ax_1+by_1=bx_2+(a \\bmod b)y_2$$我们又知道$$a \\bmod b = a - \\lfloor\\frac{a}{b}\\rfloor \\times b$$所以上式可以化为$$ax_1+by_1=bx_2+( a - \\lfloor\\frac{a}{b}\\rfloor \\times b)y_2$$展开得到$$ax_{1} + by_{1} = ay_{2} + bx_{2} - \\lfloor \\frac{a}b \\rfloor \\times by_{2}$$整理得到$$ax_1 + by_1 = ay_2+b(x2-\\lfloor \\frac{a}b \\rfloor \\times y_2)$$可以看出$$\\begin{equation}{x1 = y2\\y1 =x2-\\lfloor \\frac{a}b \\rfloor \\times y_2} \\end{equation}$$这样，我们找到了$x_1,x_2,y_1,y_2$之间的关系,也就是$ax_1+by_1=bx_2+(a \\bmod b)y_2$的两组解之间的关系，但是我们并不知道他们之间的任何一个值，但是我们知道gcd在递归过程的最后，b一定会等于0，根据欧几里得算法我们知道此时的$a$就是$gcd(a,b)$的值,所以此时的$x$为1，而由于b为0，y可以为任意值，不妨就设其为0。此时，我们知道了一组$x,y$ 的值，也知道相邻两组$x,y$的关系，就可以在递归回溯时更新$x,y$ 回溯结束求得x,y值。 代码： 12345void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y) //d为gcd(a,b){ if(b){exgcd(b,a%b,d,y,x);y-=(x*a/b);} //x,y递归时修改 else {d = a,x = 1,y = 0;}} exgcd的一大用法：求逆元(常用于求mod非质数的逆元) 根据逆元定理$$ax=1 \\pmod p$$可以转化为$$ax + kp = 1 ( k \\subset N)$$此时就转化为了经典的$ax+by=gcd(a,b) $ 代码： 1234567891011void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y){ if(b){exgcd(b,a%b,d,y,x);y-=(x*a/b);} else {d = a,x = 1,y = 0;}}int inv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 { int d,x,y; exgcd(a,mod,d,x,y); return d == 1 ? (x % mod + mod) % mod : -1;} 中国剩余定理（CRT） 中国剩余定理，又称中国余数定理，是数论中的一个关于一元线性同余方程组的定理，说明了一元线性同余方程组有解的准则以及求解方法。 定理内容： 存在n个方程组 （$b_1,b_2\\dotsb_n$均两两互质）$$\\begin{equation}{ x \\equiv a_1 \\pmod {b_1}\\ x \\equiv a_2 \\pmod {b_2}\\ x \\equiv a_3 \\pmod {b_3}\\ x \\equiv a_n \\pmod {b_n}\\}\\end{equation}$$定义$$M = \\prod_{i=1}^{n}b_i\\m_i =\\frac{M}{b_i}\\t_i=m_i^{-1} (t_i为m_i的数论倒数即逆元)$$则$$x=\\sum_{i=1}^{n} a_im_it_i + kM (k\\subset N)$$板子题：luogu P3868 猜数字 AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;ll a[15],b[15];ll qmul(ll x,ll y,ll mod){ ll res = 0; while(y){ if(y &amp; 1) res = (res + x) % mod; x = (x + x) % mod; y &gt;&gt;= 1; } return res;}void exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y){ if(b){exgcd(b,a%b,d,y,x);y-= x * (a/b);} else {x = 1,y =0,d = a;}}ll china(){ ll lcm = 1; ll ans = 0; for(int i = 0;i &lt; n;++i) lcm *= b[i]; for(int i = 0;i &lt; n;++i){ ll gcd,x,y; exgcd(lcm/b[i],b[i],gcd,x,y); x = (x%b[i] + b[i]) % b[i]; ans += qmul(qmul(a[i] , lcm / b[i] ,lcm), x,lcm); } return (ans%lcm + lcm) % lcm; }int main(){ cin&gt;&gt;n; for(int i = 0;i &lt; n;++i) cin&gt;&gt;a[i]; for(int i = 0;i &lt; n;++i) cin&gt;&gt;b[i]; printf(\"%lld\\n\",china()); return 0;} 扩展中国剩余定理（EXCRT）扩展中国剩余定理同样是求解一元线性同余方程组的方法，与中国剩余定理不同的是它的使用范围更广，它对$b_i$之间没有两两互质的要求。 求解excrt的方法是倍增法 假设我们已经求得了前i个方程的最小解，得到$$x \\equiv a_i\\pmod {b_i}\\x \\equiv a_{i+1} \\pmod {b_{i+1}}$$即$$x = a_i + k_1b_i\\x = a_{i+1}+k_2b_{i+1}$$两式相减$$k_1b_{i}-k_2b_{i+1}=a_{i+1}-a_i$$两边同除$gcd(b_i,b_{i+1})$(为方便设$gcd = gcd(b_i,b_{i+1})$) 得到$$\\frac{b_i}{gcd}k_1 = \\frac{a_{i+1}-a_i}{gcd} + \\frac{b_{i+1}}{gcd}k_2$$即$$\\frac{b_i}{gcd}k_1 = \\frac{a_{i+1}-a_i}{gcd} \\pmod {\\frac{b_{i+1}}{gcd}}$$两边同除$\\frac{b_i}{gcd}$ ，得到$$k_1 \\equiv \\frac{a_{i+1}-a_i}{gcd} \\times (\\frac{b_i}{gcd})^{-1} \\pmod {\\frac{b_{i+1}}{gcd}}$$化简$$k_1 \\equiv \\frac{a_{i+1}-a_i}{gcd} \\times (\\frac{b_i}{gcd})^{-1} + t \\times {\\frac{b_{i+1}}{gcd}}$$其中$(\\frac{b_i}{gcd})^{-1}$ 为模$\\frac{b_{i+1}}{gcd}$下的$\\frac{b_i}{gcd}$的数论倒数，即逆元 令$$k_0=\\frac{a_{i+1}-a_i}{gcd} \\times (\\frac{b_i}{gcd})^{-1}$$回代入$x = a_i + k_1b_i$ 得到：$$\\begin{equation}\\begin{aligned}x &amp;= a_i+k_1b_i\\&amp;=a_i+(k_0 + t \\times {\\frac{b_{i+1}}{gcd}}) \\times b_i\\&amp;=a_i+k_0b_i \\pmod{\\frac{b_i \\times b_{i+1}}{gcd}}\\&amp;=a_i + k_0b_i \\pmod{lcm(b_i,b_{i+1})}\\end{aligned}\\end{equation}$$等等，我们好像忘了一件重要的事情😨,$k_0$的值好像忘了求. 我们设方程$$K_1b_i-K_2b_{i+1}=gcd（b_i,b_{i+1}）$$因此使用exgcd可以得到上述方程的最小整数解$K_1$ 。（此时方程有解条件是$\\frac{a_{i+1}-a_i}{gcd(b_i,b_{i+1})}$为整数） 将得到的解带入方程后两边同时乘$\\frac{a_{i+1}-a_i}{gcd(b_i,b_{i+1})}$得到$$k_1= \\frac{(a_{i+1}-a_i)}{gcd(b_i,b_{i+1})} \\times K_1$$ 证毕，费了这么多唇舌最后求得的结论就是：$$x \\equiv kb_i+a_i \\pmod{lcm(b_1,b_2\\dots,b_{i+1})}$$倍增合并最后就可求得x的真正值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;int n;ll a[MAXN],b[MAXN];void exgcd(ll a,ll b, ll&amp;d,ll &amp;x, ll &amp;y){ if(b) {exgcd(b,a%b,d,y,x),y -= x * (a/b);} else {d = a,x = 1,y = 0;}}ll mul(ll x,ll y,ll mod){ ll res = 0; while(y){ if(y &amp; 1ll) res = (res + x)%mod; x = (x &lt;&lt; 1ll) % mod; y &gt;&gt;= 1ll; } return (res % mod + mod) % mod;}ll excrt(){ ll A = a[0],B = b[0],x,y,gcd,tmp; //A = ai B = bi x = k for(int i = 1;i &lt; n;++i){ exgcd(B,b[i],gcd,x,y); //x = K1 tmp = ((a[i] - A) % b[i] + b[i])%b[i]; if(tmp % gcd) return -1; x = mul(x,tmp /gcd,b[i]/gcd); A = (A + x * B); B = (B /gcd * b[i]); //递推增加B,即lcm(b1,b2,...,bn) ,先除后乘防止溢出 A = (A + B) % B; } return A;}int main(){ cin&gt;&gt;n; for(int i = 0;i &lt; n;++i){ cin&gt;&gt;b[i]&gt;&gt;a[i]; } printf(\"%lld\\n\",excrt()); return 0;} 欧拉函数 在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目 123456789101112131415161718//基于线性素数筛改写的欧拉筛void init() { memset(notprime, 0, sizeof(notprime)); for (int i = 2; i &lt; maxn; i++) { if (!notprime[i]) prime[cnt++] = i; for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt; maxn; j++) { notprime[i * prime[j]] = 1; if (!(i % prime[j])){ phi[prime[j] * i] = prime[j] * phi[i]; break; } else{ phi[prime[j] * i] = (prime[j] - 1) * phi[i]; } } } } 123456789101112131415//欧拉函数直接求法(唯一分解定理思路)int Euler(int x){ int res = x; for(int i = 2;i &lt;= sqrt(x);++i){ if(x % i == 0) res = res / i * (i - 1); while(x % i == 0) x /= i; } if(x &gt; 1){ res = res / x * (x - 1); } return res;} 降幂公式：$${\\forall}k &lt; \\varphi(m) 有a^{k \\bmod \\varphi(m) + \\varphi(m)}成立，其中\\varphi(m)为欧拉函数。$$ 康托展开 康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。设有n个数（1，2，3，4,…,n），可以有组成不同(n!种)的排列组合，康托展开表示的就是是当前排列组合在n个不同元素的全排列中的名次。 原理：$$X=a[n](n-1)!+a[n-1](n-2)!+…+a[i](i-1)!+…+a[1]0!$$","link":"/post/数论小结/"}],"tags":[{"name":"ICPC","slug":"ICPC","link":"/tags/ICPC/"},{"name":"题解","slug":"题解","link":"/tags/题解/"},{"name":"图论","slug":"图论","link":"/tags/图论/"},{"name":"tarjan","slug":"tarjan","link":"/tags/tarjan/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"康托展开","slug":"康托展开","link":"/tags/康托展开/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"板子","slug":"板子","link":"/tags/板子/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"gcd&exgcd","slug":"gcd-exgcd","link":"/tags/gcd-exgcd/"},{"name":"crt&excrt","slug":"crt-excrt","link":"/tags/crt-excrt/"},{"name":"欧拉函数","slug":"欧拉函数","link":"/tags/欧拉函数/"}],"categories":[{"name":"解题报告","slug":"解题报告","link":"/categories/解题报告/"},{"name":"学习总结","slug":"学习总结","link":"/categories/学习总结/"},{"name":"Notes","slug":"Notes","link":"/categories/Notes/"}]}