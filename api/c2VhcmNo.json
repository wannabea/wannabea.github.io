[{"title":"Cpp3","date":"2019-07-06T04:34:32.000Z","updated":"2019-07-06T04:34:32.962Z","content":"","plink":"http://rainyblog.top/post/cpp3/"},{"title":"Hdu3836","date":"2019-05-30T13:49:26.000Z","updated":"2019-05-30T14:11:24.324Z","content":"题目链接:http://acm.hdu.edu.cn/showproblem.php?pid=3836\ntarjan强连通分量缩点入门题.\n最近想搞一搞图论吧..但是又菜的一批,网络流又搞不动,就只能玩玩最短路,强连通分量的水题这样子.就这么一道水题数组开小了不RE,TLE是怎么回事…害得我debug半小时心态爆炸.\n题意证明两集合等价需要证明A是B子集和B是A子集,且性质可以传递,现在有n个子集,m个已知证明,求最少还需多少次证明得到所有集合均等价.\n题解tarjan求强连通分量缩点,填边使余下的强连通点构成一个强连通图即可.\n具体来说就是将每个集合看为一个圆点共n个,tarjan缩为cnt个方点.求所有方点中入度为0点记a个,出度为0点b个.需要添加的边就是max(a,b)个.\n代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Problem : 3836 ( Equivalent Sets )     Judge Status : Accepted// RunId : 29352864    Language : G++    Author : nicknameuser// Code Render Status : Rendered By HDOJ G++ Code Render Version 0.01 Beta#include &lt;bits/stdc++.h&gt;using namespace std;#define mem(a,b)  memset(a,b,sizeof(a))const int MAXN = 20000 + 10;struct Edge&#123;    int to,next;&#125;edge[MAXN * 3];int Stack[MAXN],head[MAXN],dfn[MAXN],low[MAXN],Belong[MAXN];bool InStack[MAXN],in[MAXN],out[MAXN];int tim,tot,cnt,top;int n,m;void init()\t\t//初始化&#123;    mem(Stack,0);    mem(head,-1);    mem(dfn,0);    mem(low,0);    mem(Belong,0);    mem(in,0);    mem(out,0);    tim = tot = cnt = top = 0;&#125;void tarjan(int u)\t\t//缩点入Belong&#123;    int v;    dfn[u] = low[u] = ++tim;    Stack[top++] = u;    InStack[u] = 1;        for(int i = head[u];i != -1 ;i = edge[i].next)&#123;        v = edge[i].to;        if(!dfn[v])&#123;                tarjan(v);            low[u] = min(low[u],low[v]);        &#125;        else if(InStack[v])            low[u] = min(low[u],dfn[v]);    &#125;    if(dfn[u] == low[u])&#123;        cnt++;        do&#123;            v = Stack[--top];            InStack[v] = 0;            Belong[v] = cnt;        &#125;while(u != v);    &#125;&#125;void addedge(int u,int v)\t//加边函数&#123;    edge[tot].to = v;    edge[tot].next = head[u];    head[u] = tot++;&#125;int main()&#123;    while(cin&gt;&gt;n&gt;&gt;m)&#123;        init();        while(m--)&#123;            int u,v;            scanf(\"%d%d\",&amp;u,&amp;v);            addedge(u,v);        &#125;        for(int i = 1 ;i &lt;= n;++i)&#123;            if(!dfn[i]) tarjan(i);        &#125;        for (int i = 1; i &lt;= n; ++i)&#123;\t\t//入度出度为零点的个数            for (int j = head[i]; j != -1; j = edge[j].next)&#123;                int v=edge[j].to;                if (Belong[v] != Belong[i])&#123;                    out[Belong[i]] = 1;                    in[Belong[v]] = 1;                &#125;            &#125;        &#125;        if(cnt == 1)&#123;\t//图为强连通图时,无需加边            puts(\"0\");            continue;        &#125;        int a,b;        a = b = 0;        for(int i = 1;i &lt;= cnt;++i)&#123;            if(!in[i]) a++;            if(!out[i]) b++;        &#125;        printf(\"%d\\n\",max(a,b));    &#125;    return 0;&#125;\n\n最近没心情写博客了…毕竟学期末实在太恐怖了,大雾,高数,高听,三门课正在教我做人,抽点时间做两道题,等全都考完把板子总结挂上吧…\n","plink":"http://rainyblog.top/post/hdu3836/"},{"title":"C++ 学习笔记(二)","date":"2019-05-23T15:54:59.431Z","updated":"2019-05-24T10:28:51.213Z","content":"decltype  类型制定符用处: 当我们不知道某个变量的类型而需要从表达式推断要定义的类型时,可以使用C++11的第二种类型说明符.,它的实际作用就是返回操作数的数据类型.在此过程中,编译器分析表达式并得到其类型,但实际运算表达式的值\n123const int ci = 0,&amp;cj = ci;decltype(ci) x = 0; \t//x 的数据类型是 const intdecltype(cj) y = x;\t\t//y 的数据类型是 const int&amp; 必须对其进行初始化,否则编译器会报错\n\ndecltype与引用\n当decltype得到的数据类型是一个引用值,那么它只能作为赋值语句的左值出现,即必须初始化.\n特性: 与auto相比,当decltype的表达式加双重括号代表其引用值.\n12int i = 42;decltyp((i)) j = i;\t//j的类型是 int&amp; 必须对其初始化\n\n","plink":"http://rainyblog.top/post/cpp2/"},{"title":"C++ 学习笔记(一)","date":"2019-05-23T15:54:26.358Z","updated":"2019-05-19T09:18:30.419Z","content":"[TOC]\n变量的声明与定义声明关键字 extern \n123extern int a; //声明int a; \t//声明并定义extern int a = 1; //定义\n\n变量可以被多次声明,仅可定义一次\n若想在多个文件中同时应用const 对象,需要在const前加extern\n1extren const int a = 100;\n\nconst 限定符对const 的引用(简称常量引用)例:\n1234int i = 42;   const int &amp;r1 = i;   const int &amp;r2 = 42;   const int &amp;r3 = r1 * 2;\n\n常量引用可以对非常量执行,但是无法修改引用值,也不能通过引用值修改常量.\n指向常量的指针const 可以令指针指向常量或非常量.\n不过指针不能修改所指对象的值.\n123456789\tconst double pi = 3.14;    const double *cptr = &amp;pi;    printf(\"%.2lf\\n\",*cptr);    double dval = 3.16;    cptr = &amp;dval;    printf(\"%.2lf\\n\",*cptr);output:3.143.16\n\n所谓指向常量的指针,仅仅是指不能通过该指针改变常量的值,但是可以通过其他方式改变\nconst指针即指针是对象,把指针本身定位常量\n即指针本身指向不可更改,但可通过其改变其指向的非常量的值\n1234int a = 0;int *const pa = &amp;a;\t\t\t\t//常量指针const double pi = 3.14;const double *const ppi = &amp;pi\t//指向常量的常量指针\n\n顶层const\n顶层const表示指针本身是个常量,\n\n而底层const表示指针所指对象是个常量.\n\n\n12345目前所见有int *const p = &amp;i; \t\t//顶层constconst double pi = 3.14;\t//顶层constconst double *ppi = &amp;pi;//底层constconst int &amp;r = i;\t\t//用于声明引用的const均为底层const\n\n分别const是底层或顶层时,按定义区分即可.\n在底层const对象的拷贝中,拷入与拷出必须拥有相同的底层const资格,或两者两者类型可以进行转换.\n常量表达式即值不会改变,且值在编译过程中就可得到\n123456例如 const int mx = 100;const int mxx = mx + 10;而如下表达式就不是const int x = get_size();\t//编译过程无法得到其值,须运行时确定int y = 10;\t\t\t\t//值不确定\n\nconstexpr限定符将变量声明为constexpr类型,可由编译器来验证变量的值是否是个常量表达式.\n且可用于声明函数,但此类函数须足够简单,能让编译器编译后即可得到结果.这样的函数,就可以去初始化constexpr变量\n123constexpr int mf = 20;constexpr int limit = mf + 1;constexpr int sz = size();\t//size() 为constexpr函数\n\nconstexpr 定义的指针和引用初始值受到严格限制.\n即定义在任何函数中的变量均不可被constexpr修饰,因为函数体内的变量定义一般并不会存放在固定地址.\n注意: 若constexpr定义中存在指针,则此指针为常量指针,即与其指向的对象无关.\n12const int *p = &amp;i;\t//指向常量的指针constexpr int *q = &amp;j; //常量指针\n\n","plink":"http://rainyblog.top/post/cpp1/"},{"title":"矩阵快速幂","date":"2019-05-22T15:01:05.000Z","updated":"2019-05-22T15:35:29.736Z","content":"矩阵快速幂啊…真是个好东西,fjut校赛题看到后心态爆炸..这板子题要是写不出不就被人拉下一题了…于是当机立断..现学2333..还好鼓捣很久之后把板子套上了…于是回来恶补矩阵快速幂,这记录一下.\n\n连矩阵都没接触过的菜鸡表示..我要先学习一下矩阵是个啥..:\n矩阵的加法和数乘都很简单百度便知,乘法才是我们矩阵快速幂需要了解的,这里介绍一下前置知识矩阵乘法.\n矩阵乘法\n两个矩阵可以相乘的矩阵需满足的条件左矩阵的列数必须要与右矩阵的行数相同简记,乘法过程就是左矩阵的行中每一个数字乘以右矩阵列中的每一个数,乘法过程如下\n\n代码实现如下(结构体中的运算符重载):\n123456789//方形矩阵.MAT operator*(MAT p) &#123;        MAT res;        for(int i=0;i&lt;M;i++)        for(int j=0;j&lt;M;j++)        for(int k=0;k&lt;M;k++)            res.a[i][j]=(res.a[i][j]+a[i][k]*p.a[k][j])%mod;        return res;    &#125;\n\n第二个前置知识.广义快速幂.所谓广义快速幂,就是指快速幂的思想(二进制思想),将中心运算修改.即\n12345678910MAT qpow(MAT a,ll b)&#123;    MAT res = //初始化;    while(b)&#123;        if(b &amp; 1) res = res * a ; //* 某种运算        a = a  * a;                         b &gt;&gt;= 1;    &#125;    return res;&#125;\n\n若是需要乘法运算,就将其* 改为+即可,若是矩阵乘运算,就将*改为矩阵乘的函数,或重载 *.\n矩阵快速幂\n介绍了这么多后,矩阵快速幂就差不多结束了….emm..毕竟两个一套就行了…\n那么下面来说说矩阵快速幂的应用.\n矩阵快速幂最棒的应用就在于它可以加速递推,例如斐波拉契数列,或随便的递推式.在O(logn)的时间复杂度下完成递推.\n","plink":"http://rainyblog.top/post/矩阵快速幂/"},{"title":"Codeforces Round #561 (Div2)","date":"2019-05-18T12:51:30.000Z","updated":"2019-05-19T10:46:35.270Z","content":"开开心心的一场div2.本菜鸡第一次上了70+分心情还是很激动的哈哈哈…\n呐,寻思着刚开了个博客得写点啥,就cf献祭了.\n嘿嘿嘿废话结束.\n\n[TOC]\n\nA. Silent Classroom签到题\n题意 :给出n(n &lt; 100)个字符串代表n个学生,有两个房间,两个首字符相同的学生若在同一房间\n就会聊天,可以组成一个无序对,要求找出两个房间中聊天对数最少的分配方案.并输出对数.\n样例:1234565mikemikemikemikemike\n\n分为两个房间(1,2,3)(4,5) 存在 + C(2,2) 123456789101112131415161718192021222324252627282930313233343536#### 题解:**存到string数组中排序,并平分相同首字母的同学,求和.**#### 代码```cppBy boluotou, contest: Codeforces Round #561 (Div. 2), problem: (A) Silent Classroom, Accepted, # #include &lt;bits/stdc++.h&gt;using namespace std;string s[105];int main()&#123;    int n;    cin&gt;&gt;n;    for(int i = 0;i &lt; n;++i)        cin&gt;&gt;s[i];    sort(s,s + n);    int ans = 0;    int tmp = 1;    for(int  i = 1;i &lt; n;++i)&#123;        if(s[i][0] == s[i-1][0]) tmp++;        else&#123;            if(tmp &gt; 2)                ans += ( (tmp/2 * (tmp/2-1)/2) ) + (((tmp-tmp/2) * ((tmp - tmp/2)-1) / 2)); //C(tmp, 2) + C(tmp-tmp/2, 2)            tmp = 1;        &#125;    &#125;        if(tmp &gt; 2)        ans += ( (tmp/2 * (tmp/2-1)/2) ) + (((tmp-tmp/2) * ((tmp - tmp/2)-1) / 2));    printf(&quot;%d\\n&quot;,ans);    return 0;&#125;\n\nB. All the Vowels Please同签到题\n题意给出一个数字k,问能否得到一个nm的方阵,使方阵每行每列均存在五元音字母aeiou.若存在以*一行输出方阵字符,否则输出-1**\n样例1234input36outputagoeuioaeiruuimaeoieauoweouoiaouimae\n\n题解暴力判断能否构成n * m 方阵(n,m &gt; 5),若可以,构建aeiou字符数组循环输出,否则输出-1\n代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;char a[6] = \"aeiou\";int main()&#123;    int k;    scanf(\"%d\",&amp;k);    int x,y;    x = y = 0;    for(int i = 5;i &lt; k;++i)&#123;        if(k % i == 0 &amp;&amp; k/i &gt;= 5)&#123;            x = i;            y = k/i;        &#125;    &#125;    if(!x) puts(\"-1\");    else&#123;        for(int i = 0;i &lt; x;++i)&#123;            for(int j = 0;j &lt; y;++j)&#123;                printf(\"%c\",a[(j + i) % 5]);            &#125;//                puts(\"\");        &#125;    &#125;    return 0;&#125;\n\n\nC. A Tale of Two Lands题意给出n个数,求出满足 min(x-y,x+y) &lt;= min(x,y) &lt;= max(x,y) &lt;= max(x-y,x+y) 的 无序对对数.\n样例12345input32 5 -3output2\n\n题解稍加分析,对于 x ,满足与其组队的y的条件为 y &gt;= (x+1)/2 &amp;&amp; y &lt;= x*2 (x,y均取绝对值) \n于是可以对其进行绝对值排序后(Onlogn),逐一寻找满足其条件的值,为防止重复寻找,只寻找[(x+1)/2,x]范围.寻找过程二分优化(Onlogn)   \n注意开long long!!! \n代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int a[200005];int main()&#123;    int n;    scanf(\"%d\",&amp;n);    for(int i = 0;i &lt; n;++i)&#123;        scanf(\"%d\",&amp;a[i]);        a[i] = abs(a[i]);    &#125;    sort(a,a + n);    long long ans = 0;    for(int i = 0;i &lt; n;++i)&#123;        int x = (a[i]+1)/2;        int pos = lower_bound(a,a+i,x)-a;        ans += (i-pos);    &#125;    printf(\"%lld\\n\",ans);    return 0;&#125;\n\n\nD. Cute Sequences","plink":"http://rainyblog.top/post/cf561/"},{"title":"新的一天,新的Blog!","date":"2019-05-18T06:42:49.000Z","updated":"2019-05-18T14:02:35.303Z","content":"哈哈哈经过一整天折腾我的blog终于要上线啦(实名认证过后)😁\n虽然这么久了也没写过两篇博客,但是我还是有决心要坚持下来的,毕竟得有个总结学习的地方对吧(严肃).\n更主要是…学过的东西全都忘得差不多了😭,才想起写点博客 毕竟我这么懒\nemm~博客主要写一些题解和对算法的一些理解吧,顺便用来记一下c++,py的学习笔记好了.\n想来这浑浑噩噩的一年也没沉淀下来啥,就有点灰心.\n😔往事不堪回首,ICPC路还远的很,亦步亦趋往前走吧.\n","plink":"http://rainyblog.top/post/新的一天-新的blog!/"},{"title":"大数运算模拟","date":"2019-05-18T04:53:40.122Z","updated":"2019-05-19T11:20:37.706Z","content":"从前的大数模拟都是自己用字符串来敲的,突然看到同学的代码后释放了很多思维,不仅敲得快还不容易错,于是找个晚上敲下大数的一些模拟,留下板子记录一下.\n\n对于负数加减模拟运算我们可以分情况讨论并编写另一个函数,即:\n\n若两数均正 1* 若两数均负 ```ans = &apos;-&apos; + add(a,b)\n\n若一正一负 1234567891011121314151617181920212223**可拟函数**```cppstring add_op(string a,string b)&#123;    string ans;    if(a[0] == &apos;-&apos; &amp;&amp; b[0] == &apos;-&apos;)&#123;        a.erase(a.begin());        b.erase(b.begin());        ans = &apos;-&apos; + big_add(a,b);    &#125;    else if(a[0] == &apos;-&apos;)&#123;        a.erase(a.begin());        ans = big_sub(b,a);    &#125;    else if(b[0] == &apos;-&apos;)&#123;        b.erase(b.begin());        ans = big_sub(a,b);    &#125;    else&#123;        ans = big_add(a,b);    &#125;    return ans;&#125;\n\n\n大数加法\n123456789101112131415161718192021222324252627282930313233343536373839404142434445//不支持负数const int MAXN = 1e8 + 10;int t[MAXN];string big_add(string a,string b)&#123;    int len1 = a.size();    int len2 = b.size();    reverse(a.begin(),a.end());         //调换顺序方便处理    reverse(b.begin(),b.end());        if(len1 &lt; len2)&#123;        swap(a,b);                      //令a是数位较长的数        swap(len1,len2);    &#125;    for(int i = 0;i &lt; len2;++i)&#123;        //t数组存在第i位上两数相加的结果,暂时不进位        t[i] = a[i] -'0' + b[i] - '0';    &#125;    for(int i = len2;i &lt; len1;++i)&#123;        t[i] = a[i] - '0';    &#125;    int flag = 0;                       //flag 标志是否需要进位    for(int i = 0;i &lt; len1;++i)&#123;        if(flag) &#123;            t[i]++;            flag = 0;        &#125;        if(t[i] &gt;= 10)&#123;            t[i]-=10;            flag = 1;        &#125;    &#125;    if(flag) t[len1] = 1;               //处理最高位是否需要进位,若不需要令最高位为 0    else t[len1] = 0;    string ans;    flag = 0;    for(int i = len1;i &gt;= 0 ;--i)&#123;      //去除前导0        if( flag == 0 &amp;&amp; t[i] == 0) continue;        flag = 1;         ans.push_back(t[i] + '0');    &#125;    if(ans.empty()) ans.push_back('0');    return ans;&#125;\n\n大数减法\n12345678910111213141516171819202122232425262728293031323334353637383940const int MAXN = 1e8 + 10;int t[MAXN];string big_sub(string a,string b)&#123;    string ans;        int len1 = a.size();    int len2 = b.size();    reverse(a.begin(),a.end());     //调换顺序便于处理    reverse(b.begin(),b.end());    for(int i = 0;i &lt; len2 ;++i)&#123;   //t数组保存第i位上两数之差        t[i] =  a[i] - b[i];    &#125;    for(int i = len2;i &lt; len1;++i)&#123;        t[i] = a[i] - '0';          //若a位数较长,则长度超过b的位结果为a[i] - 0    &#125;    int flag = 0;    for(int i = 0;i &lt; len1;++i)&#123;    //借位        if(flag)&#123;            flag = 0;            t[i]--;        &#125;        if(t[i] &lt; 0)&#123;            t[i]+=10;            flag = 1;        &#125;    &#125;    flag = 0;    for(int i = len1-1;i &gt;= 0;--i)&#123; //去除前导0        if(!flag &amp;&amp; t[i] == 0) continue;        flag = 1;        ans.push_back(t[i] + '0');    &#125;    if(ans.empty()) ans.push_back('0');     //若结果为0,答案 ans = 0    return ans;&#125;\n\n大数乘法\n123456789101112131415161718192021222324252627282930313233int t[10000000];string mul(string a,string b)&#123;    reverse(a.begin(),a.end());                     //交换顺序，方便计算    reverse(b.begin(),b.end());        int len1=a.size();    int len2=b.size();    for(int i = 0;i &lt; len1;++i)        for(int j = 0;j &lt; len2;++j)            t[i+j]=(a[i]-'0')*(b[j]-'0')+t[i+j];    //先整体乘起来，不进位        t[len1 + len2 -1] = 0;                          //进位    for(int i = 0;i &lt; len1 + len2;++i)&#123;        t[i+1] += t[i] / 10;        t[i] %= 10;    &#125;    int x = len1 + len2;                            //结果最长的位数    if(t[len1 + len2-1] == 0)  x--;        string ans = \"\";                                    int flag = 1;                                   //flag用来做做去除前导零的标记    for(int i = x-1;i &gt;= 0;--i)&#123;        if(t[i] == 0 &amp;&amp; flag) &#123;            continue;        &#125;        flag = 0;        ans.push_back(t[i] + '0');    &#125;    if(ans.empty()) ans.push_back('0');            //若结果为零,返回\"0\"    return ans;&#125;\n\n大数求模\n12345678910//大数求模就很简单了,根据同余定理来按位求模就好了long long big_mod(string a,long long mod)&#123;    int len=a.size();    long long ans=0;    for(int i=0;i&lt;len;++i)        ans=(ans*10%mod+a[i]-&apos;0&apos;)%mod;    return ans;&#125;","plink":"http://rainyblog.top/post/大数/"},{"title":"一维树状数组详解","date":"2019-05-18T03:00:25.000Z","updated":"2019-05-19T10:46:51.542Z","content":"树状数组的简洁易用简直是比赛神器..而且理解也不难   我这样的菜鸡都学会了\n那么就写一篇教程权当总结吧..以免日后忘了..\n\n要了解树状数组,首先需要了解它是用来做什么的.那么:\n树状数组的问题模型\n单点维护,区间查询(PUIQ问题)\n\n区间维护,单点查询(IUPQ问题)\n\n求逆序对问题\n\n树状数组的逻辑模型如图:突然一看可能难以理解,那么是什么把它们联系起来的呢?接下来介绍lowbit函数\n\n\nlowbit(求二进制数最后一位1的位置)这里用到了补码的原理:\n即负数的补码为其二进制绝对值取反+1,而当其与其绝对值取&amp;操作时得到的恰好就是其二进制最后一位1的位置\n例如:00001000(8)的负数补码为11111000(-8) 与操作后为00001000\n而lowbit(8)的值就为 00001000;\n则 lowbit函数代码\n1234inline int lowbit(int x)&#123;    return x &amp; -x;&#125;\n\n这里就稍微偏个题顺便介绍一下inline(内联函数)\n\nC++关键字，在函数声明或定义中函数返回类型前加上关键字inline，即可以把函数指定为内联函数。\n\n在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。此关键字仅是对编译器的一种建议,并非强制.对于内容较短且无循环的代码,inline的使用可以增加函数运行的效率,但其效率的增加是以代码长度为代价,所以,仅在短且无循环的函数前可以使用,其他情况避免使用.\n原理\n那么lowbit函数的用处是什么呢.\n让我们以二进制思维稍微注意一下可以发现,每个序号的二进制数的后导0的个数,恰为其包含的数组的深度(自底向上的),设其为d,那么其包含的范围就是包括它向前的2^d个数.如100(4)为从100向前4个原数组中的数的和,而110(6)是从110向前2个原数组中的数的和.\n我们令原数组为a[],树状数组为tree[].\n这时,我们可以理解tree数组中存储的到底是什么数据,那么对于以上问题模型,我们该如何求解呢.\n\n更新(update函数)我们要更新原数组中某一个数,那么就得更新树状数组中所有包含它的数据,那么,都有哪组数据包含它呢,也就是寻找这个子节点的所有根节点的特点.\n这时,就又轮到我们的lowbit函数上场了,x的所有父节点只需+ lowbit(x)```就可以得到.12345678那么update函数的代码(时间复杂度O(logn)):```cpp//x为需要修改的节点,v为a[x]增加的值,n是树状数组的最大范围.void update(int x,int v)&#123;    for(;x &lt;= n;x += lowbit(x))        tree[x] += v;&#125;\n\n查询(query函数)对于树状数组tree,我们可以了解其存储的值实质上是某一区间的前缀和.我们查询某一段区间(x,y)的值,就只需要求出y的前缀和减去x-1的前缀和这样得到的,就是区间(x,y)的和.\n那么(1,x)区间的前缀和怎么求呢,仍然是lowbit函数,只需要做一遍更新的逆过程,即计算tree数组(x-&gt;1)的和就可以求出所有不重合的区间前缀和.\n为什么tree(x-&gt;1)就是该区间的前缀和?\n在二进制的视角下,x的数位上每一个1,都代表其一段域内的值,那么,每个1都必然与其他1的范围不重合例如:12345678910如此,query的代码就很明了了.```cppint query(int x)&#123;    int res = 0;    for(;x &gt; 0;x -= lowbit(x))        res += tree[x];    return res;&#125;\n板子题链接(luoguP3374)\n\n到此为止,我们讲解的就是PUIQ模型,即点更新,段查询.\n怎么样代码是不是短到怀疑人生,这在赛场上写起来不是舒舒服服?\n那么,接下来的IUPQ模型,就需要一个切入点来完成操作了.\n\nIUPQ模型的解题切入点—差分当我们想要进行段更新时,那么如果仍然用上面的代码,就不得不添加一个for循环,此时update函数的时间复杂度会上升到O(nlogn),那么,有没有什么方法来优化操作呢?解决方案就是–差分\n差分,也就是定义一个差分数组b来存储a数组的差值,而tree作为数组b的树状数组.\n即:\n1234567b[1] = a[1]b[2] = a[2] - a[1]b[4] = a[4] - a[1]tree[1] = b[1]tree[2] = b[2] + tree[1]tree[4] = tree[2] + tree[3] + b[4]\n\n那么这时的a数组值该如何得到呢?\n对于b数组,+...+b[n]```12345而query函数刚好就是用来求b[n]的前缀和,也就是a[n]的值.那么更新操作呢,对于差分数组b,若我们想要更新```[l,r]```范围内的值+v,那么我们只需要将```b[l]```更新为```b[l] + v```就代表着```a[l] - a[n]```所有数都+1,而在```b[r+1]```处将+v的效果消除,即```b[r+1] - v\n那么如何将这个操作更新在tree数组中,就是上文update的事情了.\n即只需更新b[l]+v,b[r+1]-v即可\n12update(l,v);update(r+1,-v);\n\n复杂度同样为O(logn)\n板子题链接(luoguP3368)\n\n求逆序对问题问题模型,给定n个整数,求出逆序整数对数(即> a[v] && u < v```的整数对)12345678看见题目我们就可以写出O(n2)的暴力for来求解,但是如何将其用树状数组来优化到O(nlogn)呢这里用到桶排序的思想.首先让问题简单化一点,让n个整数a[i]均小于等于100.那么我们就可以开tree[105]的数组,每次读入更新一个数时,只需```update(a[i],1)\n此时,比a[i]大的数字就是需要更新的逆序对对数,即- query(a[i])```因为当前共读入了i个数,那么求值亦可简化为```i - query[a[i]]```12345678910111213141516171819202122也就是读入一轮+每次查询就可得到总共的逆序对对数.时间复杂度O(nlogn)那么当数据足够大时,我们的数组存不下的时候呢,这时候,就轮到我们的核心思想,离散化出场了.对于离散化,个人理解就是由于想要利用桶数组,故将数据相对缩小(保证相对大小不变)到可以开到的数组那么大而减小空间需求.那么到底该如何实现,请看如下代码:```cpp离散化核心代码:struct node&#123;    int v;//数值本身    int order;//原序列的的下标&#125;a[500005];int dis[500005];   //用来存储原数第i个数的order下标是什么sort(a,a+n,cmp);  //注意需要由大到小排for(int i = 1;i &lt;= n;++i)    dis[a[i].order] = i;\n原理很简单就只是按a[i].v的大小重排,并重新赋予他们相对大小不变,整体缩小的新的a[i].v\n具体代码如下:(HDU2689)\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define mem(n) memset(n,0,sizeof(n))using namespace std;int n;struct node&#123;    int val,order;    bool operator &lt; (const node &amp; x) const&#123;        return this-&gt;val &lt; x.val;    &#125; &#125;a[1005];int dis[1005];  //差分数组int tree[1005];inline int lowbit(int x)&#123;    return x &amp; -x;&#125;void update(int x,int v)&#123;    for(;x &lt;= n;x +=lowbit(x))        tree[x] += v;&#125;int query(int x)&#123;    int res = 0;    for(;x &gt; 0;x -= lowbit(x))        res += tree[x];    return res;&#125;int main()&#123;    while(~scanf(\"%d\",&amp;n))&#123;        mem(a);        mem(dis);        mem(tree);        for(int i = 1;i &lt;=n;++i)&#123;            scanf(\"%d\",&amp;a[i].val);            a[i].order = i;        &#125;        sort(a + 1, a + 1 + n);        for(int i = 1;i &lt;= n;++i)&#123;            dis[a[i].order] = i;        &#125;        int cnt = 0;        for(int i = 1;i &lt;= n;++i)&#123;            update(dis[i],1);            cnt += i - query(dis[i]);        &#125;        printf(\"%d\\n\",cnt);    &#125;    return 0;&#125;","plink":"http://rainyblog.top/post/一维树状数组详解/"}]