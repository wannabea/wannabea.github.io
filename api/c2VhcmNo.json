[{"title":"[新的一天,新的blog!]","date":"2019-05-18T14:42:49.000Z","updated":"2019-05-18T06:42:49.589Z","content":"","plink":"http://wannabea.github.io/post/新的一天-新的blog!/"},{"title":"大数运算模拟","date":"2019-05-18T12:53:40.122Z","updated":"2019-05-18T05:23:31.408Z","content":"从前的大数模拟都是自己用字符串来敲的,突然看到同学的代码后释放了很多思维,不仅敲得快还不容易错,于是找个晚上敲下大数的一些模拟,留下板子记录一下.\n对于负数加减模拟运算我们可以分情况讨论并编写另一个函数,即:\n\n若两数均正 1* 若两数均负 ```ans = &apos;-&apos; + add(a,b)\n\n若一正一负 1234567891011121314151617181920212223**可拟函数**```cppstring add_op(string a,string b)&#123;    string ans;    if(a[0] == &apos;-&apos; &amp;&amp; b[0] == &apos;-&apos;)&#123;        a.erase(a.begin());        b.erase(b.begin());        ans = &apos;-&apos; + big_add(a,b);    &#125;    else if(a[0] == &apos;-&apos;)&#123;        a.erase(a.begin());        ans = big_sub(b,a);    &#125;    else if(b[0] == &apos;-&apos;)&#123;        b.erase(b.begin());        ans = big_sub(a,b);    &#125;    else&#123;        ans = big_add(a,b);    &#125;    return ans;&#125;\n\n\n大数加法123456789101112131415161718192021222324252627282930313233343536373839404142434445//不支持负数const int MAXN = 1e8 + 10;int t[MAXN];string big_add(string a,string b)&#123;    int len1 = a.size();    int len2 = b.size();    reverse(a.begin(),a.end());         //调换顺序方便处理    reverse(b.begin(),b.end());        if(len1 &lt; len2)&#123;        swap(a,b);                      //令a是数位较长的数        swap(len1,len2);    &#125;    for(int i = 0;i &lt; len2;++i)&#123;        //t数组存在第i位上两数相加的结果,暂时不进位        t[i] = a[i] -'0' + b[i] - '0';    &#125;    for(int i = len2;i &lt; len1;++i)&#123;        t[i] = a[i] - '0';    &#125;    int flag = 0;                       //flag 标志是否需要进位    for(int i = 0;i &lt; len1;++i)&#123;        if(flag) &#123;            t[i]++;            flag = 0;        &#125;        if(t[i] &gt;= 10)&#123;            t[i]-=10;            flag = 1;        &#125;    &#125;    if(flag) t[len1] = 1;               //处理最高位是否需要进位,若不需要令最高位为 0    else t[len1] = 0;    string ans;    flag = 0;    for(int i = len1;i &gt;= 0 ;--i)&#123;      //去除前导0        if( flag == 0 &amp;&amp; t[i] == 0) continue;        flag = 1;         ans.push_back(t[i] + '0');    &#125;    if(ans.empty()) ans.push_back('0');    return ans;&#125;\n\n大数减法12345678910111213141516171819202122232425262728293031323334353637383940const int MAXN = 1e8 + 10;int t[MAXN];string big_sub(string a,string b)&#123;    string ans;        int len1 = a.size();    int len2 = b.size();    reverse(a.begin(),a.end());     //调换顺序便于处理    reverse(b.begin(),b.end());    for(int i = 0;i &lt; len2 ;++i)&#123;   //t数组保存第i位上两数之差        t[i] =  a[i] - b[i];    &#125;    for(int i = len2;i &lt; len1;++i)&#123;        t[i] = a[i] - '0';          //若a位数较长,则长度超过b的位结果为a[i] - 0    &#125;    int flag = 0;    for(int i = 0;i &lt; len1;++i)&#123;    //借位        if(flag)&#123;            flag = 0;            t[i]--;        &#125;        if(t[i] &lt; 0)&#123;            t[i]+=10;            flag = 1;        &#125;    &#125;    flag = 0;    for(int i = len1-1;i &gt;= 0;--i)&#123; //去除前导0        if(!flag &amp;&amp; t[i] == 0) continue;        flag = 1;        ans.push_back(t[i] + '0');    &#125;    if(ans.empty()) ans.push_back('0');     //若结果为0,答案 ans = 0    return ans;&#125;\n\n大数乘法123456789101112131415161718192021222324252627282930313233int t[10000000];string mul(string a,string b)&#123;    reverse(a.begin(),a.end());                     //交换顺序，方便计算    reverse(b.begin(),b.end());        int len1=a.size();    int len2=b.size();    for(int i = 0;i &lt; len1;++i)        for(int j = 0;j &lt; len2;++j)            t[i+j]=(a[i]-'0')*(b[j]-'0')+t[i+j];    //先整体乘起来，不进位        t[len1 + len2 -1] = 0;                          //进位    for(int i = 0;i &lt; len1 + len2;++i)&#123;        t[i+1] += t[i] / 10;        t[i] %= 10;    &#125;    int x = len1 + len2;                            //结果最长的位数    if(t[len1 + len2-1] == 0)  x--;        string ans = \"\";                                    int flag = 1;                                   //flag用来做做去除前导零的标记    for(int i = x-1;i &gt;= 0;--i)&#123;        if(t[i] == 0 &amp;&amp; flag) &#123;            continue;        &#125;        flag = 0;        ans.push_back(t[i] + '0');    &#125;    if(ans.empty()) ans.push_back('0');            //若结果为零,返回\"0\"    return ans;&#125;\n\n大数求模12345678910//大数求模就很简单了,根据同余定理来按位求模就好了long long big_mod(string a,long long mod)&#123;    int len=a.size();    long long ans=0;    for(int i=0;i&lt;len;++i)        ans=(ans*10%mod+a[i]-&apos;0&apos;)%mod;    return ans;&#125;","plink":"http://wannabea.github.io/post/大数/"},{"title":"一维树状数组详解","date":"2019-05-18T11:00:25.000Z","updated":"2019-05-18T04:54:41.305Z","content":"要了解树状数组,首先需要了解它是用来做什么的.那么:\n树状数组的问题模型\n单点维护,区间查询(PUIQ问题)\n区间维护,单点查询(IUPQ问题)\n求逆序对问题\n\n\n先来了解一下树状数组的逻辑模型如图:突然一看可能难以理解,那么是什么把它们联系起来的呢?接下来介绍lowbit函数\nlowbit(求二进制数最后一位1的位置)这里用到了补码的原理:\n即负数的补码为其二进制绝对值取反+1,而当其与其绝对值取&amp;操作时得到的恰好就是其二进制最后一位1的位置\n例如:00001000(8)的负数补码为11111000(-8) 与操作后为00001000\n而lowbit(8)的值就为 00001000;\n则 lowbit函数代码\n1234inline int lowbit(int x)&#123;    return x &amp; -x;&#125;\n\n这里就稍微偏个题顺便介绍一下inline(内联函数)\n\nC++关键字，在函数声明或定义中函数返回类型前加上关键字inline，即可以把函数指定为内联函数。\n\n在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。此关键字仅是对编译器的一种建议,并非强制.对于内容较短且无循环的代码,inline的使用可以增加函数运行的效率,但其效率的增加是以代码长度为代价,所以,仅在短且无循环的函数前可以使用,其他情况避免使用.\n原理\n那么lowbit函数的用处是什么呢.\n让我们以二进制思维稍微注意一下可以发现,每个序号的二进制数的后导0的个数,恰为其包含的数组的深度(自底向上的),设其为d,那么其包含的范围就是包括它向前的2^d个数.如100(4)为从100向前4个原数组中的数的和,而110(6)是从110向前2个原数组中的数的和.\n我们令原数组为a[],树状数组为tree[].\n这时,我们可以理解tree数组中存储的到底是什么数据,那么对于以上问题模型,我们该如何求解呢.\n\n更新(update函数)我们要更新原数组中某一个数,那么就得更新树状数组中所有包含它的数据,那么,都有哪组数据包含它呢,也就是寻找这个子节点的所有根节点的特点.\n这时,就又轮到我们的lowbit函数上场了,x的所有父节点只需+ lowbit(x)```就可以得到.12345678那么update函数的代码(时间复杂度O(logn)):```cpp//x为需要修改的节点,v为a[x]增加的值,n是树状数组的最大范围.void update(int x,int v)&#123;    for(;x &lt;= n;x += lowbit(x))        tree[x] += v;&#125;\n\n查询(query函数)对于树状数组tree,我们可以了解其存储的值实质上是某一区间的前缀和.我们查询某一段区间(x,y)的值,就只需要求出y的前缀和减去x-1的前缀和这样得到的,就是区间(x,y)的和.\n那么(1,x)区间的前缀和怎么求呢,仍然是lowbit函数,只需要做一遍更新的逆过程,即计算tree数组(x-&gt;1)的和就可以求出所有不重合的区间前缀和.\n为什么tree(x-&gt;1)就是该区间的前缀和?\n在二进制的视角下,x的数位上每一个1,都代表其一段域内的值,那么,每个1都必然与其他1的范围不重合例如:12345678910如此,query的代码就很明了了.```cppint query(int x)&#123;    int res = 0;    for(;x &gt; 0;x -= lowbit(x))        res += tree[x];    return res;&#125;\n板子题链接(luoguP3374)\n\n到此为止,我们讲解的就是PUIQ模型,即点更新,段查询.\n怎么样代码是不是短到怀疑人生,这在赛场上写起来不是舒舒服服?\n那么,接下来的IUPQ模型,就需要一个切入点来完成操作了.\n\nIUPQ模型的解题切入点—差分当我们想要进行段更新时,那么如果仍然用上面的代码,就不得不添加一个for循环,此时update函数的时间复杂度会上升到O(nlogn),那么,有没有什么方法来优化操作呢?解决方案就是–差分\n差分,也就是定义一个差分数组b来存储a数组的差值,而tree作为数组b的树状数组.\n即:\n1234567b[1] = a[1]b[2] = a[2] - a[1]b[4] = a[4] - a[1]tree[1] = b[1]tree[2] = b[2] + tree[1]tree[4] = tree[2] + tree[3] + b[4]\n\n那么这时的a数组值该如何得到呢?\n对于b数组,+...+b[n]```12345而query函数刚好就是用来求b[n]的前缀和,也就是a[n]的值.那么更新操作呢,对于差分数组b,若我们想要更新```[l,r]```范围内的值+v,那么我们只需要将```b[l]```更新为```b[l] + v```就代表着```a[l] - a[n]```所有数都+1,而在```b[r+1]```处将+v的效果消除,即```b[r+1] - v\n那么如何将这个操作更新在tree数组中,就是上文update的事情了.\n即只需更新b[l]+v,b[r+1]-v即可\n12update(l,v);update(r+1,-v);\n\n复杂度同样为O(logn)\n板子题链接(luoguP3368)\n\n求逆序对问题问题模型,给定n个整数,求出逆序整数对数(即> a[v] && u < v```的整数对)12345678看见题目我们就可以写出O(n2)的暴力for来求解,但是如何将其用树状数组来优化到O(nlogn)呢这里用到桶排序的思想.首先让问题简单化一点,让n个整数a[i]均小于等于100.那么我们就可以开tree[105]的数组,每次读入更新一个数时,只需```update(a[i],1)\n此时,比a[i]大的数字就是需要更新的逆序对对数,即- query(a[i])```因为当前共读入了i个数,那么求值亦可简化为```i - query[a[i]]```12345678910111213141516171819202122也就是读入一轮+每次查询就可得到总共的逆序对对数.时间复杂度O(nlogn)那么当数据足够大时,我们的数组存不下的时候呢,这时候,就轮到我们的核心思想,离散化出场了.对于离散化,个人理解就是由于想要利用桶数组,故将数据相对缩小(保证相对大小不变)到可以开到的数组那么大而减小空间需求.那么到底该如何实现,请看如下代码:```cpp离散化核心代码:struct node&#123;    int v;//数值本身    int order;//原序列的的下标&#125;a[500005];int dis[500005];   //用来存储原数第i个数的order下标是什么sort(a,a+n,cmp);  //注意需要由大到小排for(int i = 1;i &lt;= n;++i)    dis[a[i].order] = i;\n原理很简单就只是按a[i].v的大小重排,并重新赋予他们相对大小不变,整体缩小的新的a[i].v\n具体代码如下:(HDU2689)\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define mem(n) memset(n,0,sizeof(n))using namespace std;int n;struct node&#123;    int val,order;    bool operator &lt; (const node &amp; x) const&#123;        return this-&gt;val &lt; x.val;    &#125; &#125;a[1005];int dis[1005];  //差分数组int tree[1005];inline int lowbit(int x)&#123;    return x &amp; -x;&#125;void update(int x,int v)&#123;    for(;x &lt;= n;x +=lowbit(x))        tree[x] += v;&#125;int query(int x)&#123;    int res = 0;    for(;x &gt; 0;x -= lowbit(x))        res += tree[x];    return res;&#125;int main()&#123;    while(~scanf(\"%d\",&amp;n))&#123;        mem(a);        mem(dis);        mem(tree);        for(int i = 1;i &lt;=n;++i)&#123;            scanf(\"%d\",&amp;a[i].val);            a[i].order = i;        &#125;        sort(a + 1, a + 1 + n);        for(int i = 1;i &lt;= n;++i)&#123;            dis[a[i].order] = i;        &#125;        int cnt = 0;        for(int i = 1;i &lt;= n;++i)&#123;            update(dis[i],1);            cnt += i - query(dis[i]);        &#125;        printf(\"%d\\n\",cnt);    &#125;    return 0;&#125;","plink":"http://wannabea.github.io/post/一维树状数组详解/"}]