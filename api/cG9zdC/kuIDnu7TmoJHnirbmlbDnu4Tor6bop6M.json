{"title":"一维树状数组详解","date":"2019-05-18T03:00:25.000Z","link":"post/一维树状数组详解","tags":["ICPC","数据结构","板子"],"categories":["ICPC"],"updated":"2019-05-19T10:46:51.542Z","content":"<p>树状数组的简洁易用简直是比赛神器..而且理解也不难   <del>我这样的菜鸡都学会了</del></p>\n<p>那么就写一篇教程权当总结吧..以免日后忘了..</p>\n<hr>\n<p>要了解树状数组,首先需要了解它是用来做什么的.<br>那么:</p>\n<h2 id=\"树状数组的问题模型\">树状数组的问题模型<a href=\"post/一维树状数组详解#树状数组的问题模型\"></a></h2><ul>\n<li><p><strong>单点维护,区间查询</strong>(PUIQ问题)</p>\n</li>\n<li><p><strong>区间维护,单点查询</strong>(IUPQ问题)</p>\n</li>\n<li><p><strong>求逆序对问题</strong></p>\n<hr>\n<h2 id=\"树状数组的逻辑模型\"><a href=\"#树状数组的逻辑模型\" class=\"headerlink\" title=\"树状数组的逻辑模型\"></a>树状数组的逻辑模型</h2><p>如图:<br><img src=\"https://i.loli.net/2019/04/08/5cab650bb66ce.jpg\" alt=\"树状数组图示.jpg\"><br>突然一看可能难以理解,那么是什么把它们联系起来的呢?<br>接下来介绍lowbit函数</p>\n</li>\n</ul>\n<h2 id=\"lowbit-求二进制数最后一位1的位置\">lowbit(求二进制数最后一位1的位置)<a href=\"post/一维树状数组详解#lowbit-求二进制数最后一位1的位置\"></a></h2><p>这里用到了补码的原理:</p>\n<p>即负数的补码为其二进制绝对值取反+1,而当其与其绝对值取&amp;操作时得到的恰好就是其二进制最后一位1的位置</p>\n<p>例如:00001000(8)的负数补码为11111000(-8) 与操作后为00001000</p>\n<p>而lowbit(8)的值就为 00001000;</p>\n<p><strong>则 lowbit函数代码</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &amp; -x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就稍微偏个题顺便介绍一下inline(内联函数)</p>\n<blockquote>\n<p>C++关键字，在函数声明或定义中函数返回类型前加上关键字inline，即可以把函数指定为内联函数。</p>\n</blockquote>\n<p>在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。<br>此关键字仅是对编译器的一种建议,并非强制.对于内容较短且无循环的代码,inline的使用可以增加函数运行的效率,但其效率的增加是以代码长度为代价,所以,仅在短且无循环的函数前可以使用,其他情况避免使用.</p>\n<h3 id=\"原理\">原理<a href=\"post/一维树状数组详解#原理\"></a></h3><hr>\n<p>那么lowbit函数的用处是什么呢.</p>\n<p>让我们以二进制思维稍微注意一下可以发现,每个序号的二进制数的后导0的个数,恰为其包含的数组的深度(自底向上的),设其为d,那么其包含的范围就是包括它向前的<strong>2^d</strong>个数.如100(4)为从100向前4个原数组中的数的和,而110(6)是从110向前2个原数组中的数的和.</p>\n<p><strong>我们令原数组为a[],树状数组为tree[].</strong></p>\n<p>这时,我们可以理解tree数组中存储的到底是什么数据,<br>那么对于以上问题模型,我们该如何求解呢.</p>\n<hr>\n<h2 id=\"更新-update函数\">更新(update函数)<a href=\"post/一维树状数组详解#更新-update函数\"></a></h2><p>我们要更新原数组中某一个数,那么就得更新树状数组中所有包含它的数据,<br>那么,都有哪组数据包含它呢,也就是寻找这个子节点的所有根节点的特点.</p>\n<p>这时,就又轮到我们的lowbit函数上场了,x的所有父节点只需<figure class=\"highlight plain\"><figcaption><span>+ lowbit(x)```就可以得到.</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">那么update函数的代码(时间复杂度O(logn)):</span><br><span class=\"line\">```cpp</span><br><span class=\"line\">//x为需要修改的节点,v为a[x]增加的值,n是树状数组的最大范围.</span><br><span class=\"line\">void update(int x,int v)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(;x &lt;= n;x += lowbit(x))</span><br><span class=\"line\">        tree[x] += v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"查询-query函数\">查询(query函数)<a href=\"post/一维树状数组详解#查询-query函数\"></a></h2><p>对于树状数组tree,我们可以了解其存储的值实质上是某一区间的前缀和.<br>我们查询某一段区间(x,y)的值,就只需要求出y的前缀和减去x-1的前缀和<br>这样得到的,就是区间(x,y)的和.</p>\n<p>那么(1,x)区间的前缀和怎么求呢,仍然是lowbit函数,只需要做一遍更新的逆过程,<br>即计算tree数组(x-&gt;1)的和就可以求出所有不重合的区间前缀和.</p>\n<p><strong>为什么tree(x-&gt;1)就是该区间的前缀和?</strong></p>\n<p>在二进制的视角下,x的数位上每一个1,都代表其一段域内的值,<br>那么,每个1都必然与其他1的范围不重合例如:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如此,query的代码就很明了了.</span><br><span class=\"line\">```cpp</span><br><span class=\"line\">int query(int x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int res = 0;</span><br><span class=\"line\">    for(;x &gt; 0;x -= lowbit(x))</span><br><span class=\"line\">        res += tree[x];</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>板子题链接(<a href=\"https://www.luogu.org/problemnew/show/P3374\" target=\"_blank\" rel=\"noopener\">luoguP3374</a>)</p>\n<hr>\n<p>到此为止,我们讲解的就是PUIQ模型,即点更新,段查询.</p>\n<p>怎么样代码是不是短到怀疑人生,这在赛场上写起来不是舒舒服服?</p>\n<p>那么,接下来的IUPQ模型,就需要一个切入点来完成操作了.</p>\n<hr>\n<h2 id=\"IUPQ模型的解题切入点—差分\">IUPQ模型的解题切入点—差分<a href=\"post/一维树状数组详解#IUPQ模型的解题切入点—差分\"></a></h2><p>当我们想要进行段更新时,那么如果仍然用上面的代码,就不得不添加一个for循环,<br>此时update函数的时间复杂度会上升到O(nlogn),那么,有没有什么方法来优化操作呢?解决方案就是–<strong>差分</strong></p>\n<p>差分,也就是定义一个差分数组b来存储a数组的差值,而tree作为数组b的树状数组.</p>\n<p>即:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b[<span class=\"number\">1</span>] = a[<span class=\"number\">1</span>]</span><br><span class=\"line\">b[<span class=\"number\">2</span>] = a[<span class=\"number\">2</span>] - a[<span class=\"number\">1</span>]</span><br><span class=\"line\">b[<span class=\"number\">4</span>] = a[<span class=\"number\">4</span>] - a[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">tree[<span class=\"number\">1</span>] = b[<span class=\"number\">1</span>]</span><br><span class=\"line\">tree[<span class=\"number\">2</span>] = b[<span class=\"number\">2</span>] + tree[<span class=\"number\">1</span>]</span><br><span class=\"line\">tree[<span class=\"number\">4</span>] = tree[<span class=\"number\">2</span>] + tree[<span class=\"number\">3</span>] + b[<span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n\n<p>那么这时的a数组值该如何得到呢?</p>\n<p>对于b数组,<figure class=\"highlight plain\"><figcaption><span>+...+b[n]```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">而query函数刚好就是用来求b[n]的前缀和,也就是a[n]的值.</span><br><span class=\"line\"></span><br><span class=\"line\">那么更新操作呢,对于差分数组b,若我们想要更新```[l,r]```范围内的值+v,那么我们只需要将```b[l]```更新为```b[l] + v```就代表着```a[l] - a[n]```所有数都+1,</span><br><span class=\"line\">而在```b[r+1]```处将+v的效果消除,即```b[r+1] - v</span><br></pre></td></tr></table></figure></p>\n<p>那么如何将这个操作更新在tree数组中,就是上文update的事情了.</p>\n<p>即只需更新b[l]+v,b[r+1]-v即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update(l,v);</span><br><span class=\"line\">update(r+<span class=\"number\">1</span>,-v);</span><br></pre></td></tr></table></figure>\n\n<p>复杂度同样为O(logn)</p>\n<p><strong>板子题链接(<a href=\"https://www.luogu.org/problemnew/show/P3368\" target=\"_blank\" rel=\"noopener\">luoguP3368</a>)</strong></p>\n<hr>\n<h2 id=\"求逆序对问题\">求逆序对问题<a href=\"post/一维树状数组详解#求逆序对问题\"></a></h2><p>问题模型,给定n个整数,求出逆序整数对数(即<figure class=\"highlight plain\"><figcaption><span>> a[v] && u < v```的整数对)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">看见题目我们就可以写出O(n2)的暴力for来求解,但是如何将其用树状数组来优化到O(nlogn)呢</span><br><span class=\"line\"></span><br><span class=\"line\">这里用到桶排序的思想.</span><br><span class=\"line\"></span><br><span class=\"line\">首先让问题简单化一点,让n个整数a[i]均小于等于100.</span><br><span class=\"line\"></span><br><span class=\"line\">那么我们就可以开tree[105]的数组,每次读入更新一个数时,只需```update(a[i],1)</span><br></pre></td></tr></table></figure></p>\n<p>此时,比a[i]大的数字就是需要更新的逆序对对数,即<figure class=\"highlight plain\"><figcaption><span>- query(a[i])```因为当前共读入了i个数,那么求值亦可简化为```i - query[a[i]]```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">也就是读入一轮+每次查询就可得到总共的逆序对对数.时间复杂度O(nlogn)</span><br><span class=\"line\"></span><br><span class=\"line\">那么当数据足够大时,我们的数组存不下的时候呢,这时候,就轮到我们的核心思想,离散化出场了.</span><br><span class=\"line\"></span><br><span class=\"line\">对于离散化,个人理解就是由于想要利用桶数组,故将数据相对缩小(保证相对大小不变)到可以开到的数组那么大而减小空间需求.</span><br><span class=\"line\"></span><br><span class=\"line\">那么到底该如何实现,请看如下代码:</span><br><span class=\"line\">```cpp</span><br><span class=\"line\">离散化核心代码:</span><br><span class=\"line\">struct node</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int v;//数值本身</span><br><span class=\"line\">    int order;//原序列的的下标</span><br><span class=\"line\">&#125;a[500005];</span><br><span class=\"line\"></span><br><span class=\"line\">int dis[500005];   //用来存储原数第i个数的order下标是什么</span><br><span class=\"line\"></span><br><span class=\"line\">sort(a,a+n,cmp);  //注意需要由大到小排</span><br><span class=\"line\"></span><br><span class=\"line\">for(int i = 1;i &lt;= n;++i)</span><br><span class=\"line\">    dis[a[i].order] = i;</span><br></pre></td></tr></table></figure></p>\n<p>原理很简单就只是按a[i].v的大小重排,并重新赋予他们相对大小不变,整体缩小的新的a[i].v</p>\n<p>具体代码如下:(<a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2689\" target=\"_blank\" rel=\"noopener\">HDU2689</a>)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mem(n) memset(n,0,sizeof(n))</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val,order;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node &amp; x) <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;val &lt; x.val;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;a[<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[<span class=\"number\">1005</span>];  <span class=\"comment\">//差分数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> tree[<span class=\"number\">1005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &amp; -x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;x &lt;= n;x +=lowbit(x))</span><br><span class=\"line\">        tree[x] += v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;x &gt; <span class=\"number\">0</span>;x -= lowbit(x))</span><br><span class=\"line\">        res += tree[x];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n))&#123;</span><br><span class=\"line\">        mem(a);</span><br><span class=\"line\">        mem(dis);</span><br><span class=\"line\">        mem(tree);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;=n;++i)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i].val);</span><br><span class=\"line\">            a[i].order = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sort(a + <span class=\"number\">1</span>, a + <span class=\"number\">1</span> + n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;++i)&#123;</span><br><span class=\"line\">            dis[a[i].order] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;++i)&#123;</span><br><span class=\"line\">            update(dis[i],<span class=\"number\">1</span>);</span><br><span class=\"line\">            cnt += i - query(dis[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,cnt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"大数运算模拟","link":"post/大数"},"plink":"http://rainyblog.top/post/一维树状数组详解/","toc":[{"title":"树状数组的问题模型","id":"树状数组的问题模型","index":"1"},{"title":"","id":"树状数组的逻辑模型","index":"2"},{"title":"lowbit(求二进制数最后一位1的位置)","id":"lowbit-求二进制数最后一位1的位置","index":"3","children":[{"title":"原理","id":"原理","index":"3.1"}]},{"title":"更新(update函数)","id":"更新-update函数","index":"4"},{"title":"查询(query函数)","id":"查询-query函数","index":"5"},{"title":"IUPQ模型的解题切入点—差分","id":"IUPQ模型的解题切入点—差分","index":"6"},{"title":"求逆序对问题","id":"求逆序对问题","index":"7"}],"copyright":{"author":"Rainy","link":"<a href=\"http://rainyblog.top/post/一维树状数组详解/\" title=\"一维树状数组详解\">http://rainyblog.top/post/一维树状数组详解/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}